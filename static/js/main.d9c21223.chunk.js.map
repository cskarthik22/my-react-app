{"version":3,"sources":["Navbar.js","cpp/Code.js","cpp/Label.js","Sketch.js","Maze.jsx","CoreAPP.js","index.js"],"names":["Navbar","class","type","id","hidden","for","href","placeholder","Code","props","programName","programCode","className","Label","webLinkName","webLink","includes","target","Sketch","p","setup","createCanvas","draw","mouseIsPressed","fill","ellipse","mouseX","mouseY","Maze","CoreAPP","state","weblinks","programs","Fibonacci","String","raw","LIS","CoinChange","HeapSort","STL","MergeSort","Star","Permutations","Parenthesis","Combinations","Reverse","Stack","Queue","Strings","NQueens","GIT","Bash","this","keys","Object","webkeys","StrictMode","map","key","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.d9c21223.chunk.js","sourcesContent":["\nfunction Navbar() {\n  return (\n  <div class=\"navbar\">\n    <input type=\"checkbox\" id=\"click\" class=\"checkbox\" hidden></input>\n   <div class=\"sidebar\">\n     <label for=\"click\">\n        <div class=\"menu-icon\">\n          <div class=\"line line-1\"></div>\n          <div class=\"line line-2\"></div>\n          <div class=\"line line-3\"></div>\n       </div>\n     </label>\n     <ul class=\"social-media-list\">\n       <li> <a href=\"https://www.facebook.com/karthik.kaluvala.1/\" class=\"social-link\"><i class=\"fab fa-facebook-f\"></i></a></li>\n       <li> <a href=\"https://linkedin.com/in/cskarthik22\" class=\"social-link\"><i class=\"fab fa-linkedin-in\"></i></a></li>\n       <li> <a href=\"https://twitter.com/cskarthik22\" class=\"social-link\"><i class=\"fab fa-twitter\"></i></a></li>\n       <li> <a href=\"https://www.instagram.com/cskarthik22\" class=\"social-link\"><i class=\"fab fa-instagram\"></i></a></li>\n \n     </ul>\n   </div>\n   \n   <nav class=\"navigation\">\n     <div class=\"navigation-header\">\n       <h1 class=\"navigation-heading\"> core cs </h1>\n       <form class=\"navigation-search\">\n         <input type=\"text\" class=\"naviation-search-input\" placeholder=\"Search...\"></input>\n         <button class=\"navigation-search-btn\">\n           <i class=\"fas fa-search\"></i>\n         </button>\n       </form>\n     </div>\n     <ul class=\"navigation-list\">\n       <li class=\"navigation-item\"><a href=\"#\" class=\"navigation-link\"> home </a></li>\n       <li class=\"navigation-item\"><a href=\"#\" class=\"navigation-link\"> Sorting </a></li>\n       <li class=\"navigation-item\"><a href=\"#\" class=\"navigation-link\"> Divide-Conquer </a></li>\n       <li class=\"navigation-item\"><a href=\"#\" class=\"navigation-link\"> Greedy </a></li>\n       <li class=\"navigation-item\"><a href=\"#\" class=\"navigation-link\"> Backtracking </a></li>\n       <li class=\"navigation-item\"><a href=\"#\" class=\"navigation-link\"> Recursion </a></li>\n       <li class=\"navigation-item\"><a href=\"#\" class=\"navigation-link\"> DP (Bitmask) </a></li>\n       <li class=\"navigation-item\"><a href=\"#\" class=\"navigation-link\"> Graphs </a></li>\n       <li class=\"navigation-item\"><a href=\"#Others\" class=\"navigation-link\"> Links </a></li>\n     </ul>\n     \n     <div class=\"copyright\">\n       <p>&copy; 2021 CoreCS All Rights Reserved.</p>\n     </div>\n   </nav>\n   <div id=\"root-div\"></div>\n </div>\n  );\n}\n\nexport default Navbar;\n","\nconst Code =(props) =>{\n    const { programName, programCode } = props;\n   \n    return (\n        <div> \n            <h1>{programName}</h1>\n            <section  id={programName} >\n                <pre className='prettyprint lang-cpp'>\n                {programCode}\n                </pre>\n            </section>\n        </div>\n    );\n  }\n  \n  export default Code;\n  ","\nconst Label =(props) =>{\n    const { webLinkName, webLink } = props;\n    const flag = webLink.includes(\"https://\")\n    if (flag) {\n        return (\n            <div class=\"label-container label\">\n                <a href={webLink} class=\"navigation-link\" target=\"_blank\"> \n                    {webLinkName} \n                </a>\n            </div>  \n        );\n    } else {\n        return (\n            <div class=\"label-container label\">\n                <a href={webLink} class=\"navigation-link\"> \n                    {webLinkName} \n                </a>\n            </div>  \n        );\n    }\n    \n  }\n  export default Label;\n  ","function Sketch(p) {\n    let rotation = 0;\n    p.setup = function () {\n        p.createCanvas(1500, 400);\n        \n    };\n\n    p.draw = function () {\n        if (p.mouseIsPressed) {\n            p.fill(0);\n        } else {\n            p.fill(255);\n        }\n        p.ellipse(p.mouseX, p.mouseY, 100, 100);\n    };\n};\n\n\nexport default Sketch;","\nfunction Maze() {\n  return (\n    \n    <div dangerouslySetInnerHTML={{ __html: \"<iframe src='./maze.html' />\"}} />\n \n  );\n}\nexport default Maze;\n","import React from 'react';\nimport './index.css';\nimport './CSS/style.css';\nimport './CSS/banner.css';\nimport './CSS/desert.css';\nimport Navbar from './Navbar';\nimport Code from './cpp/Code';\nimport Label from './cpp/Label';\n\n//import reportWebVitals from './reportWebVitals';\nimport P5Wrapper from 'react-p5-wrapper';\nimport Sketch from './Sketch';\n//import CartItem from './JSX/CartItem';\nimport Maze from './Maze';\n<P5Wrapper Sketch={Sketch} /> \n\nclass CoreAPP extends React.Component {\n  constructor () {\n      super();\nthis.state = \n{\nweblinks : {\n  \"Fibonacci\": \"#Fibonacci\",\n  \"CoinChange\": \"#CoinChange\",\n  \"LIS\": \"#LIS\",\n  \"HeapSort\": \"#HeapSort\",\n  \"MergeSort\": \"#MergeSort\",\n  \"STL\": \"#STL\",\n  \"Star\": \"#Star\",\n  \"Parenthesis\": \"#Parenthesis\",\n  \"Permutations\": \"#Permutations\",\n  \"Combinations\": \"#Combinations\",\n  \"Func-Pointers\": \"#Func-Pointers\",\n  \"Reverse\": \"#Reverse\",\n  \"Stack\": \"#Stack\",\n  \"Queue\": \"#Queue\",\n  \"Strings\": \"#Strings\",\n  \"GIT\": \"#GIT\",\n  \"NQueens\": \"#NQueens\",\n  \"Bash\": \"#Bash\",\n  \"SRE\": \"https://github.com/cskarthik22/howtheysre\",\n  \"Netshoot\": \"https://github.com/cskarthik22/netshoot\",\n  \"DP-1\": \"https://www.topcoder.com/thrive/articles/dynamic-programming-and-local-memoization-in-competitive-programming\",\n  \"DP-2\": \"https://www.topcoder.com/thrive/articles/dynamic-programming-and-local-memoization-part-2\",\n  \"DP-3\": \"https://www.youtube.com/watch?v=P8Xa2BitN3I\",\n  \"FFT\": \"https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/\",\n  \"Others\": \"https://github.com/cskarthik22/coding-interview-university\",\n  \"Big-O\": \"https://github.com/cskarthik22/Notes/blob/master/Books/big-o-cheatsheet.pdf\",\n  \"Entropy\": \"https://www.youtube.com/watch?v=JnJq3Py0dyM&t=176s\",\n  \"basecs\": \"https://medium.com/basecs/tagged/data-structures\",\n  \"Docker\": \"http://docker-saigon.github.io/post/Docker-Internals/\",\n  \"Linux\": \"https://cheatsheet.dennyzhang.com/cheatsheet-linuxinternals-a4\",\n  \"iNode\": \"https://www.thegeekstuff.com/2012/01/linux-inodes/\",\n  \"k8s-deploy-strategies\": \"https://github.com/ContainerSolutions/k8s-deployment-strategies\",\n  \"sysadmin\": \"https://sysadmincasts.com/\",\n  \"C/C++\": \"https://github.com/cskarthik22/Notes/tree/master/stanford/C/C%26C%2B%2B\",\n  \"Binary Trees\": \"http://cslibrary.stanford.edu/110/BinaryTrees.html\",\n  \"Algo-01\": \"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\",\n  \"Algo-02\": \"https://visualgo.net/en\",\n  \"ebooks\": \"https://epdf.pub/search/data+structures\",\n  \"*IMP*\": \"http://courses.csail.mit.edu/iap/interview/materials.php\",\n  \"PKI\": \"https://www.youtube.com/watch?v=qXLD2UHq2vk\",\n  \"VPN\": \"https://www.youtube.com/watch?v=4BfL0UHrzDY\",\n  \"DNS\": \"https://howdns.works/ep1/\",\n  \"HTTPS\": \"https://howhttps.works/why-do-we-need-https/\",\n  \"Network-Slides\": \"http://indigoo.com/\",\n  \"Free Courses\": \"https://www.openculture.com/computer_science_free_courses\",\n  \"API\": \"https://www.mulesoft.com/resources/api/what-is-an-api\",\n  \"System Design\": \"https://cheatsheet.dennyzhang.com/cheatsheet-systemdesign-a4\",\n  \"Leet Code\": \"https://www.youtube.com/watch?v=U6-X_QOwPcs&list=PLU_sdQYzUj2keVENTP0a5rdykRSgg9Wp-\",\n  \"Secure Web API\": \"https://github.com/cskarthik22/Notes/tree/master/Security\",\n  \"Memory\": \"http://cse1.net/recaps/memory.html\",\n  \"Channel9\": \"https://channel9.msdn.com/Browse/AllContent\",\n  \"JS\": \"https://bost.ocks.org/mike/algorithms/\",\n  \"P5js\": \"https://thecodingtrain.com/\",\n  \"Network_Packets_3D\": \"https://youtu.be/xIuBmOufbls\",\n  \"Codeshare.io\": \"https://codeshare.io/\",\n  \"WhiteBoard\": \"https://cocreate.csail.mit.edu/\" \n},\nprograms : {\n  Fibonacci: String.raw`\n  int fibo(int n) {\n    if( n==0 || n==1) \n        return 1;\n    return fibo(n-1) + fibo(n-2);\n }\n\n int fibo_dp_bottomup(int n) {\n    /* Effective space utilization, instead of array, just maintain\n       only 2 varaibles */\n    int first = 1;\n    int second = 1;\n    int ans = 0;\n    if (n==0 || n==1)\n        return 1;\n    for(int i=2; i<=n; i++) {\n        ans = second + first;\n        first = second;\n        second = ans;\n    }\n    return ans;\n}\n\nint fibo_dp_topdown(int n, int* dp) {\n    // Memoization = Recursion + lookup table\n    if( n==0 || n==1) {\n        return 1;\n    }\n    if(dp[n]!= -1) {\n        return dp[n];\n    }\n    int ans = fibo_dp_topdown(n-1, dp) +\n              fibo_dp_topdown(n-2, dp);\n    dp[n] = ans;\n    \n    return ans;\n}                \n`,\nLIS: String.raw`\nint LIS(int* inputarr, int size) {\n  int* lis_arr = new int[size];\n  for(int i=0; i<size; i++)\n  lis_arr[i]=1;\n  \n  for(int i=1; i<size; i++){\n      for(int j=0; j<i; j++) {\n          if(inputarr[i]>inputarr[j] && lis_arr[i] < lis_arr[j]+1) {\n              lis_arr[i] = lis_arr[j]+1;\n          }\n      }\n  }\n  int maxlength= 0;\n  for( int i=0; i<size; i++) {\n      if(lis_arr[i] > maxlength) {\n          maxlength = lis_arr[i];\n      }\n  }\n  delete [] lis_arr;\n  return maxlength;\n}`,\nCoinChange: String.raw`\nint coin_change_dp_bottomup(int amount, int* denomintions, int size) {\n  int *ways = new int[amount+1];\n  for(int i=0; i< amount+1; i++) {\n      ways[i] = 0;\n  }\n  ways[0] = 1;\n  for(int i=1; i<size; i++) {\n      for(int j=1; j<amount+1; j++) {\n          if( denomintions[i] <= j ) {\n              ways[j] = ways[j] + ways[j-denomintions[i]];\n          }\n      }\n  }\n  int ans = ways[amount];\n  delete [] ways;\n  return ans;\n};\n\nint coin_change_dp_topdown(int amount, int* denomintions, int size, int** output) {\n  if(amount == 0)\n      return 1;\n  \n  if(amount < 0)\n      return 0;\n  \n  if(size == 0)\n      return 0;\n  \n  if(output[amount][size] &gt; -1)\n      return output[amount][size];\n  \n  int option1 = coin_change_dp_topdown(amount-denomintions[0],denomintions,size,output);\n  int option2 = coin_change_dp_topdown(amount, denomintions+1, size-1, output);\n  output[amount][size] = option1 + option2;\n  \n  return option1 + option2;\n}\n\nint coin_change(int amount, int* denomintions, int size) {\n  \n  if(amount == 0)\n      return 1;\n  \n  if(amount < 0)\n      return 0;\n  \n  if(size == 0)\n      return 0;\n  /*\n   option1: choose first denomination\n   option2: don't choose first denomination\n   */\n  int option1 = coin_change(amount-denomintions[0],denomintions, size);\n  int option2 = coin_change(amount, denomintions+1, size-1);\n  return option1 + option2;\n}`,\nHeapSort: String.raw`\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid swapfunc(vector<pair<double,string>> &vp, int large, int index) {\n    pair<double, string> tp = vp[index];\n    vp[index] = vp[large];\n    vp[large] = tp;\n }\n\nvoid MaxHeapify(vector<pair<double,string>> &vp, int index, int n) {\n    int left = 2*index+1;\n    int right = 2*index+2;\n    int large = index;\n    \n    if(left < n && vp[left].first > vp[index].first) {\n        large = left;\n    } else {\n        large = index;\n    }\n    \n    if(right < n && vp[right].first >vp[large].first) {\n        large = right;\n    }\n    if( large != index) {\n        swapfunc(vp, large, index);\n        MaxHeapify(vp, large, n);\n    }\n}\n\nvoid BuildMapHeap(vector<pair<double,string>> &vp, int n) {\n    for( int i=n/2-1; i>=0; i--) {\n        MaxHeapify(vp, i, n);\n    }\n}\n\nvoid HeapSort(vector<pair<double,string>> &vp, int n) {\n    \n    for( int i=n-1; i>0; i--) {\n        swapfunc(vp, 0, i);\n        MaxHeapify(vp, 0, i);\n    }\n}\n\nint main()\n{\n    vector<pair<double,string>> vp;\n    int n;\n    cin >> n;\n  \n    for( int i=0; i <n; i++) {\n        double item;\n        string name;\n        cin >> item >> name;\n        pair<double,string> p = make_pair(item, name);\n        vp.push_back(p);\n    }\n    \n    cout << endl;\n    // 1 14 10 8 7 9 3 2 4 6\n    for(auto it = vp.begin(); it != vp.end(); it++){\n        cout << (*it).first << \" - \" << (*it).second  << endl;\n    }\n    BuildMapHeap(vp, n);\n    \n    //HeapSort(vp, n);\n    \n    cout << \" Max heap\" << endl;\n    \n    for(auto it = vp.begin(); it != vp.end(); it++){\n        cout << (*it).first << \" - \" << (*it).second  << endl;\n    }\n\n    return 0;\n}\n/*\n5                    \n1 one                        \n4 four                        \n2 two                       \n5 five                       \n3 three\n*/`,\nSTL: String.raw`\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <forward_list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <tuple>\nusing namespace std;\n\n/*\nlist - doublelinked list\nforward-list - single linked list\n*/\n\nvoid display(vector<int> &v){\n    cout << \"vector display\" << endl;\n    auto it = v.begin();\n    while(it != v.end()){\n        cout << *it << \" \";\n        it++;\n    }\n    cout << endl;\n}\n\nvoid display_list(list<int> &v){\n    cout << \"list display\" << endl;\n    list<int>::iterator it;\n    it = v.begin();\n    while(it != v.end()){\n        cout << *it << \" \";\n        it++;\n    }\n    cout << endl;\n}\n\nvoid display_forard_list(forward_list<int> &v){\n    cout << \"forward_list display\" << endl;\n    forward_list<int>::iterator it;\n    it = v.begin();\n    while(it != v.end()){\n        cout << *it << \" \";\n        it++;\n    }\n    cout << endl;\n}\n\nint main()\n{\n    vector<int> v = { 1,2,10,23,12 };\n    v.push_back(25);\n    display(v);\n    v.pop_back();\n    display(v);\n    \n    list<int> l = { 1,2,10,23,12 };\n    l.push_back(25);\n    display_list(l);\n    \n    forward_list<int> fl = { 1,2,10,23,12 };\n    fl.push_front(25);\n    display_forard_list(fl);\n    \n    \n    stack<int> s;\n    s.push(100);\n    s.push(200);\n    s.push(250);\n    while(!(s.empty())) {\n        cout << s.top() << \" \";\n        s.pop();\n    }\n    cout << endl;\n    \n    queue<int> q;\n    q.push(100);\n    q.push(200);\n    q.push(250);\n    while(!(q.empty())){\n        cout << q.front() << \" \";\n        q.pop();\n    }\n    cout << endl;\n    \n    pair<int,string> p;\n    p = make_pair(10, \"john\");\n    cout << p.first << p.second << endl;\n    \n    vector<pair<int,string>> vp;\n    vp.push_back(make_pair(1,\"one\"));\n    vp.push_back(make_pair(2,\"two\"));\n    vp.push_back(make_pair(3,\"three\"));\n    \n    for(auto it = vp.begin(); it != vp.end(); it++){\n        cout << (*it).first << \" \" << (*it).second << endl;\n    }\n    \n    tuple<int, string, int> t;\n    t = make_tuple(10, \"john\", 35);\n    cout << get<0>(t) << \" \" << get<1>(t) << \" \" << get<2>(t) << endl;\n    \n    vector<tuple<int,string,int>> vt;\n    vt.push_back(make_tuple(10, \"john\", 35));\n    vt.push_back(make_tuple(20, \"mike\", 55));\n    vt.push_back(make_tuple(30, \"carl\", 45));\n    \n    for(auto it=vt.begin(); it!=vt.end(); it++){\n        cout << get<0>(*it) << \" \" << get<1>(*it) << \" \" << get<2>(*it) << endl;\n    }\n    \n    priority_queue<pair<int,string>> pq;\n    pq.push(make_pair(10,\"john\"));\n    pq.push(make_pair(30,\"carl\"));\n    pq.push(make_pair(20,\"mike\"));\n    \n    while(!(pq.empty())){\n        cout << pq.top().first << \" \" << pq.top().second << endl;\n        pq.pop();\n    }\n    \n    return 0;\n}`,\nMergeSort: String.raw`\n#include <stdio.h>\n    #include <stdlib.h>\n    \n    void Merge(int *arr, int low, int mid, int high) {\n        int n1 = mid - low + 1;\n        int n2 = high - mid;\n        \n        int arr1[n1],arr2[n2];\n        int i,j,k=0;\n        \n        for(i=0;i<n1;i++)\n           arr1[i]=arr[low+i];\n        for(j=0;j<n2;j++)\n          arr2[j]=arr[mid+1+j];\n          i=0;\n          j=0;\n          k=low;\n          while(i<n1 && j<n2) {\n              if(arr1[i]<=arr2[j]) \n                  arr[k++]=arr1[i++];\n              else \n                  arr[k++] = arr2[j++];\n          }\n          while(i<n1){\n              arr[k++] = arr1[i++];\n          }\n          while(j<n2){\n              arr[k++] = arr2[j++];\n          }\n        //printf(\"done...\");\n    }\n    \n    void MergeSort(int *arr,int low, int high){\n        int mid; \n        if(low<high) {\n            mid = low + (high-low)/2;\n            MergeSort(arr,low,mid);\n            MergeSort(arr,mid+1,high);\n            Merge(arr,low,mid,high);\n        }\n    }\n    \n    void Display(int *arr){\n        for(int i=0;arr[i]!=NULL;i++)\n            printf(\"%d \",arr[i]);\n    }\n    int main()\n    {\n        int A[]={1,14,10,8,7,9,3,2,4,6};\n        int arrlen = sizeof(A)/sizeof(int);\n        Display(&A);\n        printf(\"\\n\");\n        MergeSort(&A,0,arrlen-1);\n        Display(&A);\n    }`,  \nStar: String.raw`\n#include <stdio.h>\n\nint main()\n{\n    int n=10;\n    \n    for(int i=1; i<=n;i++){\n        int spaces = n-i;\n        for(int j = 1; j<=2*spaces; j++) printf(\" \"); //first in row\n        for(int j = 1; j<=i; j++) printf(\"   A\"); // middle in row\n        for(int j = 1; j<=2*spaces; j++) printf(\" \"); // last in row\n        printf(\"\\n\");\n    }\n    for(int i=n-1; i>=1;i--){\n        int spaces = n-i;\n        for(int j = 1; j<=2*spaces; j++) printf(\" \");\n        for(int j = 1; j<=i; j++) printf(\"   A\");\n        for(int j = 1; j<=2*spaces; j++) printf(\" \");\n        printf(\"\\n\");\n    }\n    \n\n    return 0;\n}\n\n/*\noutput:\n\n                     A                                                                                                                                           \n                   A   A                                                                                                                                         \n                 A   A   A                                                                                                                                       \n               A   A   A   A                                                                                                                                     \n             A   A   A   A   A                                                                                                                                   \n           A   A   A   A   A   A                                                                                                                                 \n         A   A   A   A   A   A   A                                                                                                                               \n       A   A   A   A   A   A   A   A                                                                                                                             \n     A   A   A   A   A   A   A   A   A                                                                                                                           \n   A   A   A   A   A   A   A   A   A   A                                                                                                                         \n     A   A   A   A   A   A   A   A   A                                                                                                                           \n       A   A   A   A   A   A   A   A                                                                                                                             \n         A   A   A   A   A   A   A                                                                                                                               \n           A   A   A   A   A   A                                                                                                                                 \n             A   A   A   A   A                                                                                                                                   \n               A   A   A   A                                                                                                                                     \n                 A   A   A                                                                                                                                       \n                   A   A                                                                                                                                         \n                     A                                             \n*/\n    `,\nPermutations: String.raw`\n// Program to permute a given string \n\n/*    \n Permutations: Deals with selection + arrangement.\n Example: select 11 out of 20 players in a cricket team and also decide batting arrangement.\n Answer: nPr => nCr * r! ==> n!/(n-r)!\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint count=0;\nchar letters[] = \"abc\";\nint *visited;\nvoid permuatations(char *str, int start, int end)\n{\n    if(start == end) {\n        printf(\"%s \", str);\n        count++;\n    } else {\n        for(int i=0;i<strlen(letters); i++) {\n            if(visited[i]==0) {\n                str[start] = letters[i];\n                visited[i] = 1;\n                permuatations(str, start+1, end);\n                visited[i] = 0;\n                str[start] = '\\0';\n            }\n        }\n    }\n}\n\nvoid main() {\n    int n=sizeof(letters);\n    char *input = (char*)calloc(n,sizeof(char));\n    visited = (int *)calloc(n,sizeof(int));\n    permuatations(input,0,n-1);\n    printf(\"\\nTotal permuatations = %d\", count);\n}\n\n/* OUTPUT\nabc acb bac bca cab cba                                                                                                                                                                     \nTotal permuatations = 6\n*/\n`,\nParenthesis: String.raw`\n// Generate all valid parenthesis\n#include <stdio.h>\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid genparenthesis(int n, int open, int close, string output){\n    if(output.size()==2*n)\n       cout << output << endl;\n    \n    if(open<n)\n       genparenthesis(n,open+1,close, output + \"(\");\n       \n    if(close<open)\n       genparenthesis(n,open,close+1, output + \")\");\n    \n}\n\nint main()\n{\n  genparenthesis(3,0,0,\"\");\n  return 0;\n}\n\n/* OUTPUT:\n          ((()))       \n          (()())                        \n          (())()                       \n          ()(())                        \n          ()()()\n\n*/\n`,\n\"Func-Pointers\": String.raw`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef void (*Funstr)(char *);\n\nvoid strLength(char *s) { \n  int i;\n  for (i = 0; s[i] != '\\0'; i++);\n  printf (\"strLength = %d\", i);\n}\n\nvoid strUpper(char *s) {\n  for (int i = 0; s[i] != '\\0'; i++) {\n    if (s[i] >= 97 && s[i] <= 122) {\n       s[i] = s[i] - 32;\n    }\n  }\n  printf (\"\\nUpper = %s\", s);\n}\n\nvoid strLower(char *s) { \n  for (int i = 0; s[i] != '\\0'; i++) {\n    if (s[i] >= 65 && s[i] <= 90) {\n\t   s[i] = s[i] + 32;\n\t}\n  }\n  printf (\"\\nLower = %s \", s);\n}\n\nvoid swap(char *a, char *b) {\n    *a = *a ^ *b;\n    *b = *a ^ *b;\n    *a = *a ^ *b;\n}\n\nvoid strReverse(char *s) {\n    \n    for(int i=0,j=strlen(s)-1;i<j;i++,j--)\n       swap(&s[i], &s[j]);\n    printf (\"\\nReverse = %s \", s);\n}\n\nvoid IsPalindrome(char *s) {\n    for(int i=0,j=strlen(s)-1;i<j;i++,j--) {\n        if (s[i] != s[j]) {\n            printf(\"%s is not a palindrome\");\n            return;\n        }\n    }\n    printf(\"\\n%s is a palindrome\", s);\n    \n}\n\nint main()\n{\n    char str1[] = \"WeLcome\" , str2[] = \"madam\";\n    \n    Funstr strOperations[] = { strLength, strUpper, strLower, strReverse, IsPalindrome };\n    strOperations[0](str1);\n    strOperations[1](str1);\n    strOperations[2](str1);\n    strOperations[3](str1);\n    strOperations[4](str1); strOperations[4](str2);\n    \n\n    return 0;\n}`,\nCombinations: String.raw`\n/*\n   Combination: Deals with only selection.\n   Example: select 11 out of 20 players in a cricket team\n   Answer: nCr => n!/((n-r)!*r!) => 20C11\n*/\n\n#include <stdio.h>\n\nstatic int count=0;\nvoid swap ( char *a, char *b)\n{\n    char temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid Combinations(char *str, int start, int end)\n{\n    int index;\n   \n    if(start == end)\n    {\n        printf(\"%s\\n\", str);\n        count++;\n    }\n    else\n    {\n        for(index = start;index<=end;index++)\n        {\n         swap(&str[start],&str[index]);\n         Combinations(str, start+1, end);\n         swap(&str[start],&str[index]);\n         \n        }\n    }\n   \n}\n\nint main()\n{\n    \n    char input[] = \"abc\";\n    Combinations(input,0,strlen(input)-1);\n    printf(\"Total Combinations = %d\", count);\n    \n    return 0;\n}\n\n/* OUTPUT:\n\n    abc                      \n    acb                          \n    bac                          \n    bca                          \n    cba                         \n    cab                                                                                                                                                              \n    Total Combinations = 6 \n\n*/`,\nReverse: String.raw`\n/*Reverese words in a given string */\n\n/*\nAlgorithm\n=========\n\nstep1: Reverse the individual words\nstep2: Reverse the whole string from start to end\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid reverse(char *start, char *end)\n{\n\tchar temp;\n\twhile(start < end)\n\t{\n\t\ttemp = *start;\n\t\t*start++ = *end;\n\t\t*end-- = temp;\n\t}\n}\n\nvoid RevereseWords(char *str)\n{\n\tchar *wordBegin, *temp;\n\twordBegin = '\\0';\n\ttemp = str;\n\t//reverse the individual words\n\twhile(*temp)\n\t{\n\t\tif((wordBegin == '\\0') && (*temp != ' '))\n\t\t\twordBegin = temp;\n\t\tif(wordBegin && ((*(temp+1) == ' ') || (*(temp + 1) == '\\0')))\n\t\t{\n\t\t\treverse(wordBegin, temp);\n\t\t\twordBegin = '\\0';\n\t\t}\n\t\ttemp++;\n\t}\n\t//reverse the whole string from start to end\n\treverse(str, temp-1);\n}\n\nint main()\n{\n\tchar str[100] = \"Welcome to Programming!!\";\n\n\tRevereseWords(str);\n\tprintf(\"%s\\n\", str);\n\treturn 0;\n}\n\n/* OUTPUT:\n\n   Programming!! to Welcome\n*/`,\nStack: String.raw`\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node_Block {\n    int data;\n    struct Node_Block *link;\n} node;\n\nnode *TOP = NULL;\n\nvoid push(int item) {\n    // Create a new node\n    node *temp = (node *)malloc(sizeof(node));\n    temp->data = item;\n    temp->link = NULL;\n    \n    if ( TOP == NULL ) {\n       TOP = temp;\n       return;\n    } \n    temp->link = TOP;\n    TOP = temp;\n}\n\nvoid pop() {\n    node *temp;\n    if ( TOP == NULL ) {\n        printf(\" Stack is empty \\n\");\n        return;\n    } \n    temp = TOP;\n    TOP=TOP->link;\n    free(temp);\n}\n\nvoid display() {\n    node *inode = TOP;\n    printf(\"[ TOP ] => \");\n    while(inode) {\n        printf(\"[ %d ] =>\", inode->data);\n        inode=inode->link;\n    }\n}\n\nvoid print_top() {\n    printf(\"%d\", TOP->data);\n}\n\nint main()\n{\n    printf(\"\\n\\t MENU: 1) PUSH 2) POP 3) TOP 4) Display 5) Exit \\n\");\n    int ch;\n    int item;\n   \n    do {\n        printf(\"enter your choice(1-5): \");\n        scanf(\"%d\",&ch);\n        \n        switch(ch) {\n            case 1:\n                printf(\"\\n Enter data : \");\n                scanf(\"%d\", &item);\n                push(item);\n                break;\n            case 2:\n                pop();\n                break;\n            case 3:\n                print_top();\n                break;\n            case 4:\n                display();\n                break;\n            case 5:\n                // Free All nodes ( clear heap memory)\n                while(TOP) {\n                    node* temp = TOP;\n                    TOP = TOP->link;\n                    free(temp);\n                    printf(\"Memory - Cleared \\n\");\n                }\n                exit(0);\n                \n            default:\n                printf(\" Wrong choice ;\\n\");\n                break;\n            \n        }\n        \n    \n    } while( ch != 5);\n\n    return 0;\n}`,\nQueue: String.raw`\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node_Block {\n    int data;\n    struct Node_Block *link;\n} node;\n\nnode *FRONT, *REAR = NULL;\n\nvoid Enqueue(int item) {\n    \n    node *temp = (node *)malloc(sizeof(node));\n    temp->data = item;\n    temp->link=NULL;\n    \n    if( REAR == NULL) {\n        FRONT = REAR = temp; \n        return;\n    }\n    REAR->link=temp;\n    REAR = temp;\n    return;\n}\n\nvoid Dequeue(){\n    if( (FRONT==NULL) && (REAR==NULL) ) {\n        printf(\"Queue is empty...\");\n    } else \n    if ( FRONT==REAR ) {\n        free(FRONT);\n        FRONT=REAR=NULL;\n    } else {\n        node *temp = FRONT;\n        FRONT=FRONT->link;\n        free(temp);\n    }\n    \n}\n\nvoid Display(){\n    node *seeknode = FRONT;\n    printf(\"[ FRONT ] => \");\n    while(seeknode) {\n        printf(\"[ %d ] => \", seeknode->data);\n        seeknode = seeknode->link;\n    }\n    printf(\"[ REAR ] => \");\n}\n\nvoid Is_Empty(){\n    \n}\n\nvoid main(){\n    \n    int ch, item;\n    node *temp;\n    printf(\"\\n\\t MENU 1) Enqueue 2) Dequeue 3) Is_Empty 4) Display 5) Exit... \");\n    do {\n        printf(\"\\n Enter choice \");\n        scanf(\"%d\", &ch);\n        switch(ch) {\n            case 1:\n                printf(\"\\nEnter item \");\n                scanf(\"%d\", &item);\n                Enqueue(item);\n                break;\n            case 2:\n                Dequeue();\n                break;\n            case 3:\n                Is_Empty();\n                break;\n            case 4:\n                Display();\n                break;\n            case 5:\n                // Free All nodes ( clear heap memory)\n                \n                while(FRONT) {\n                    temp = FRONT;\n                    FRONT = FRONT->link;\n                    free(temp);\n                    printf(\"Memory-Cleared\\n\");\n                }\n                exit(0);\n            \n        }\n    \n    } while(ch != 5);\n    \n}`,\nStrings: String.raw`\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid swap(char *a, char *b) {\n// with out temp variable using bitwise XOR operation.\n    *a = *a^*b;\n    *b = *a^*b;\n    *a = *a^*b;\n}\n\nvoid swapUsingTemp(char *a, char *b) {\n    char t;\n    t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid strReverse( char *s) {\n    int i=0, j=strlen(s)-1;\n    \n    while(i < j) {\n        swap(&s[i], &s[j]);\n        //swapUsingTemp(&s[i], &s[j]);\n        i++;\n        j--;\n    }\n    printf(\"\\nReverse = %s \", s);\n}\n\nvoid strReverse01( char *s) {\n    for(int i=0, j=strlen(s)-1;i < j; i++,j--) \n       swap(&s[i], &s[j]);\n    \n    printf(\"\\nReverse01 = %s \", s);\n}\n\nvoid findlength (char *s)\n{\n  int i;\n  for (i = 0; s[i] != '\\0'; i++);\n\n  printf (\"length of %s is %d\", s, i);\n}\n\nvoid strUpper (char *s)\n{\n  int i;\n  for (i = 0; s[i] != '\\0' && (s[i] >= 97 && s[i] <= 122); i++)\n    {\n      // if( s[i] >= 97 && s[i] <=122) {\n      s[i] = s[i] - 32;\n      //  }\n    }\n  printf (\"\\nUpper = %s\", s);\n}\n\nvoid strLower (char *s)\n{\n  int i;\n  for (i = 0; s[i] != '\\0'; i++)\n    {\n      if (s[i] >= 65 && s[i] <= 90)\n\t{\n\t  s[i] = s[i] + 32;\n\t}\n    }\n  printf (\"\\nLower = %s \", s);\n}\n\nchar* substr(char *str,int pos,int n){\n    char *s = (char *)malloc(n*sizeof(char));\n    for(int i=pos;str[i]!='\\0';i++)\n       s[i-pos]=str[i];\n  return s;\n}\n\nvoid main ()\n{\n\n  char str1[] = \"weLcome\";\n\n  findlength (str1);\n  strUpper (str1);\n  strLower (str1);\n  strReverse(str1);\n\n}`,\nNQueens: String.raw`\n#include <stdio.h>\n#include <stdlib.h>\n#define SIZE 4\n\nvoid printSolution(int board[SIZE][SIZE]) {\n    int i,j;\n    printf(\"=======SOL========\\n\");\n    for (i = 0; i < SIZE; i++)\n    {\n        for (j = 0; j < SIZE; j++)\n           printf(\" %d \", board[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"=================\\n\");\n}\n\nint isSafe(int board[SIZE][SIZE],int row, int col) {\n    /*\n     \\\n      \\\n    ___\\(i,j)\n      /\n    /\n    \n    */\n    int i,j;\n    for (j=0; j <col; j++) {\n        if(board[row][j])\n          return 0;\n    }\n    for (i=row, j=col; i>=0 && j>=0; i--,j--)\n        if(board[i][j])\n          return 0;\n    for (i=row, j=col; j>=0 && i<SIZE; i++,j--)\n        if(board[i][j])\n          return 0;\n    return 1;\n} \n\nvoid solveNQueen(int board[SIZE][SIZE], int col) {\n    \n    // BASE CASE\n    if (col >= SIZE) {\n        printSolution(board);\n        \n    } else {\n        \n        for(int row=0;row<SIZE;row++) {\n        \n            if (isSafe(board,row,col)) {\n                \n                //CHOOSE\n                board[row][col] = 1;\n                \n                //EXPLORE\n                solveNQueen(board, col+1);\n                \n                //UNCHOOSE\n                board[row][col] = 0;\n            }\n        }\n        \n    }\n    \n}\n\nvoid main ()\n{\n    int board[SIZE][SIZE] = {0};\n\n    solveNQueen(board,0);\n}`,\nGIT: String.raw`\nGIT - Directed Acylic Graph\ngit \ngit add .\ngit commit -m'modified'\ngit commit -a -m'add & commit in single step'\ngit status\ngit show\n\ngit remote -v\ngit log --pretty=oneline --graph\ngit log -p\ngit log <<commitid>> HEAD -p\ngit log <<commitid>> HEAD^^^^^..HEAD^^\ngit log <<commitid>> HEAD~5..HEAD~2\n\ngit branch branch-01 // new branch created by userA\ngit checkout branch-01\ngit checkout -b branch-02 // new branch created by userB\ngit branch // shows local branches\ngit branch -a //shows all branches includes remote branches\n** Remote branches are locally immutable\n\nuser-01:\ngit checkout -b branch-02\necho \"hello\" >> hellotest.txt\ngit commit -a -m'new filed added by user-01 for the branch created by user-02\"\n\nUser-02 is on Branch-02:\ngit branch --set-upstream <<localbranch>> <<remote refspec>> \ngit branch --set-upstream branch-02 origin/branch-02  // now tracking is done bi-directional\ngit pull // now it merges remote origin to local automatically\n\n\n\ngit branch yesterday <<commitid>>\n\ngit push command talks to the network\n\ngit push\ngit push origin <<branchName>>\ngit push remote <<branchName>>\n\ngit fetch \ngit diff branch-02 origin/branch-02\n\ngit tags are like markers\ngit tag <<TAGNAME>>  // light weight\ngit tag -a <<TAGNAME>> // Heavy Weight\n`,\nBash: String.raw`\n**************************************** LINUX BOOT PROCESS ***********************************\n\n1. BIOS on the mother board checks all the input/output devices and the boot process for the computer begins.\n2. The Boot process ( GRUB / other ) looks for a section of a hard drive ( Boot sector ) that contains the data to \n   load operating system. \n3. Boot loader -> loads the linux Kernel.\n4. Linux Kernel -> load the initial RAM disk, which contains a list of device drivers and then it starts to load \n   the computer drives to eventually mount the file system from the hard disk.\n5. After the kernel is all setup and ready to to go, it then starts the initialization system\n\nVarious Initialization Systems are...\ninit --> upstart --> systemd \n\nSystemd is the most popular one.\n\ninit/upstart relies on bash shell scripts, but systemd replaced all the exisiting fucntionality with pre-compiled 'C' code.\nAdvandtages of systemd:\n1) Socket activation\n2) parallel execution\n\nLinux Kernel has a concept, which manages all the system resources in a hierarchial grouping & labeling called\nControl Groups (Cgroups)\nEach Cgroups - Limits the use of the system resources ( CPU, RAM ..etc )\nEach Namespace - Limits the view of the processes , creating a logical isolated boundary.\n\nSystemd took advantage of Cgroups & grouped all its processes together into their own type of Cgroups, which has its own slice \nof resource pie\n\nSystemd manages the units of services grouped together approproately names slices\n\nsystemd-cgls\nsystemd-cgtop\n\nsystemctl\nsystemctl status httpd.service\nsystemctl enable httpd.service\nsystemclt disable httpd.service\nsystemctl is-enabled httpd.servoce\nsystemctl help httpd.service\nsystemctl start httpd.service\nsystemctl stop httpd.service\nsystemctl cat httpd.service\nsystemctl mask httpd.service\nsystemctl unmask httpd.service\nsystemctl -H 198.0.0.1 status httpd.service\nsystemctl daemon-reload\nsystemctl list-unit-files\nsystemd-delta\nsystemctl edit --full <unit>\n\nsystemd journal\n\njournalctl \njournalctl -r\njournalctl -o verbose\njournalctl -o json-pretty\necho \" hello... \" | systemd-cat\njournalctl -r\njournalctl -f\njournalctl -n 20\njournalctl -k ### kernal logs\njournalctl --disk-usage\n\nhostnamectl\ntimedatectl\nlocalectl\nsystemd-analyse\n\n\nsystemd-inhibit wget http://example.com/abc.iso   ### prevents system from sleeping until it downloads huge file.\n\n/etc/fstab\ndf -Th\nlsblk\n\n\nlsmod # list kernal modules\nlscpu # displays cpu architecture\nlspci\nlsblk\nlsusb\nlsdev\n\n\n#### Special Characters\n\nsu root -  ( ### '-' at the end will make sure all the configuration settings applied to switch user root )\n/bin/false && echo 'it wont print'\n/bin/true && echo ' now it prints'\n/bin/true || echo 'it wont print'\n/bin/false || echo 'it prints'\n/bin/false; echo 'prints whatever'\n\\\\ \\$ ( ### escape characters )\n### return codes 0-true, 1 -false\necho $?\nls -al | more  ( ### '|' pipe symbol gives pagination)\nls -al > output.txt ( ### redirects output to a file )\n\n###### Environment Variables\n\nset | more\nenv | more\nshopt\nexport MYPATH = /home/user\necho $MYPATH\nhistory\n\n\n###### Processing texts\nhttps://github.com/linuxacademy1/textfiles\n\nsort numbers.txt\nsort -n numbers.txt\nsort -k2 -n numbers.txt ( ### sort second column in the text file )\ncat numbers.txt\nnl numbers.txt ( ### like cat it dispalys contents with line numbers exluding blank lines )\nnl -ba numbers.txt ( ## number blank lines)\nwc -l /etc/passwd ( ### number of lines in a file )\nwc -w /etc/passwd ( ### number of words )\nwc -c /etc/passwd ( ### number of characters )\nexpand -t 10 tabs.txt ( ### 10 spaces between each column )\ncut -c 1-5 columns.txt\ncut -d: -f 1,2,4 columns.txt\ncut -d\" \" -f 1,2 columns.txt  ( ### tab is default delimeter no need to mention )\npaste file1.txt file2.txt\njoin file1.txt file2.txt ( ### only has unique values)\nuniq lines.txt\nuniq -d lines.txt  ( ### print only duplicate unique lines )\nuniq -D lines.txt ( ### print only duplicate lines \nhead /var/log/messages ( ### displays first 10 lines )\nhead -n 15 /var/log/messages\ntail /var/log/messages\ntail -n 15 /var/log/messages\ntail -f /var/log/messages ( with updates automatically )\ncat tabs.txt\ntac tabs.txt ( ### displays content in reverse )\nsplit lines.txt\nsplit -b 512 lines.txt  ( ### 512 bytes in each file)\nsplit -k 512 lines.txt  ( ### 512 kilobytes in each file)\nsplit -l 10 lines.txt ( ### 10 lines in each file - xaa.txt)\nsplit -a 3 -l 10 lines.txt ( ### output file name xaaa.txt)\nod telnet.rpm ( ### displays binary file in octal format, other formats -b , -o, -x, -d, -f)\npr lines.txt ( ### prints the contents of the file to terminal )\npr --columns=2 lines.txt ( ### prints in 2 columns )\n\ntr 'a' 'A' < lines.txt ( ### translate command replaces a with A , but we cant use tr to replace entire word)\ntr 'a-e' 'A-E' < lines.txt \n\nTo replace entire word we use SED unility\nsed 's/the/THE/g' sedexamples.txt ( ### substitiutes the with THE globally across the file )\nsed 's/the/THE/' sedexamples.txt ( ###replaces only first instance in each line not globally )\nsed -e 's/the/NOW/g' -e 's/NOW/NEVER/g' sedexamples.txt ( ### multiple commands in a single line )\nvim sedopts.txt\ns/the/THE/g\ns/THE/NOW/g\ns/NOW/NEVER/g\n\nsed -f sedopts.txt sedexamples.txt\nmore lines.txt ( displays content page wise using tab space and it allows only forward)\nless lines.txt ( f forward b for backword)\n\n\nBasic File Management\nls -l /etc\nls -al /etc\nls -d ( lists the directories)\nmkdir -p mydir/dir1/dir2/dir3 ( creates all sub directories)\nfile /etc/* ( diplays file types information )`,\n\n\n\n        }\n      }\n      \n     // this.testing();\n    // <CartItem  qty={1} price={990} title={\"Phone\"} pic={\"\"} />\n  }\n  render() {\n    const { programs, weblinks } = this.state;\n    const keys = Object.keys(programs);\n    const webkeys = Object.keys(weblinks);\n      return(\n        <React.StrictMode>\n        <div id=\"root-div\">\n        <Navbar />\n            <header className=\"header\">\n               <div class=\"label-container\">\n                  { webkeys.map((key) => {\n                      return (\n                        <Label webLink={weblinks[key]} webLinkName={key}/>\n                      )\n                    }) \n                  }\n               </div>\n            </header>\n            <div id=\"container\">\n            { keys.map((key) => {\n                  return (\n                    <Code programCode={programs[key]} programName={key}/>\n                  )\n              }) \n            }\n           \n            </div>\n         </div>\n         <P5Wrapper Sketch={Sketch} />\n         \n       </React.StrictMode>\n      \n      );\n  }\n}\n\nexport default CoreAPP;\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport './CSS/style.css';\nimport './CSS/banner.css';\nimport './CSS/desert.css';\n\n\n//import reportWebVitals from './reportWebVitals';\n//import P5Wrapper from 'react-p5-wrapper';\n//import sketch from './Sketch';\n//import CartItem from './JSX/CartItem';\nimport CoreAPP from './CoreAPP';\nReactDOM.render(\n  <React.StrictMode>\n  <CoreAPP />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}