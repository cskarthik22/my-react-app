(this["webpackJsonpmy-react-app"]=this["webpackJsonpmy-react-app"]||[]).push([[0],{18:function(n,i,t){"use strict";t.r(i);var e=t(1),r=t.n(e),a=t(8),s=t.n(a),o=(t(4),t(5),t(6),t(7),t(2)),c=t(9),l=t(10),d=t(12),h=t(11),p=t(0);var u=function(){return Object(p.jsxs)("div",{class:"navbar",children:[Object(p.jsx)("input",{type:"checkbox",id:"click",class:"checkbox",hidden:!0}),Object(p.jsxs)("div",{class:"sidebar",children:[Object(p.jsx)("label",{for:"click",children:Object(p.jsxs)("div",{class:"menu-icon",children:[Object(p.jsx)("div",{class:"line line-1"}),Object(p.jsx)("div",{class:"line line-2"}),Object(p.jsx)("div",{class:"line line-3"})]})}),Object(p.jsxs)("ul",{class:"social-media-list",children:[Object(p.jsxs)("li",{children:[" ",Object(p.jsx)("a",{href:"https://www.facebook.com/karthik.kaluvala.1/",class:"social-link",children:Object(p.jsx)("i",{class:"fab fa-facebook-f"})})]}),Object(p.jsxs)("li",{children:[" ",Object(p.jsx)("a",{href:"https://linkedin.com/in/cskarthik22",class:"social-link",children:Object(p.jsx)("i",{class:"fab fa-linkedin-in"})})]}),Object(p.jsxs)("li",{children:[" ",Object(p.jsx)("a",{href:"https://twitter.com/cskarthik22",class:"social-link",children:Object(p.jsx)("i",{class:"fab fa-twitter"})})]}),Object(p.jsxs)("li",{children:[" ",Object(p.jsx)("a",{href:"https://www.instagram.com/cskarthik22",class:"social-link",children:Object(p.jsx)("i",{class:"fab fa-instagram"})})]})]})]}),Object(p.jsxs)("nav",{class:"navigation",children:[Object(p.jsxs)("div",{class:"navigation-header",children:[Object(p.jsx)("h1",{class:"navigation-heading",children:" core cs "}),Object(p.jsxs)("form",{class:"navigation-search",children:[Object(p.jsx)("input",{type:"text",class:"naviation-search-input",placeholder:"Search..."}),Object(p.jsx)("button",{class:"navigation-search-btn",children:Object(p.jsx)("i",{class:"fas fa-search"})})]})]}),Object(p.jsxs)("ul",{class:"navigation-list",children:[Object(p.jsx)("li",{class:"navigation-item",children:Object(p.jsx)("a",{href:"#",class:"navigation-link",children:" home "})}),Object(p.jsx)("li",{class:"navigation-item",children:Object(p.jsx)("a",{href:"#",class:"navigation-link",children:" Sorting "})}),Object(p.jsx)("li",{class:"navigation-item",children:Object(p.jsx)("a",{href:"#",class:"navigation-link",children:" Divide-Conquer "})}),Object(p.jsx)("li",{class:"navigation-item",children:Object(p.jsx)("a",{href:"#",class:"navigation-link",children:" Greedy "})}),Object(p.jsx)("li",{class:"navigation-item",children:Object(p.jsx)("a",{href:"#",class:"navigation-link",children:" Backtracking "})}),Object(p.jsx)("li",{class:"navigation-item",children:Object(p.jsx)("a",{href:"#",class:"navigation-link",children:" Recursion "})}),Object(p.jsx)("li",{class:"navigation-item",children:Object(p.jsx)("a",{href:"#",class:"navigation-link",children:" DP (Bitmask) "})}),Object(p.jsx)("li",{class:"navigation-item",children:Object(p.jsx)("a",{href:"#",class:"navigation-link",children:" Graphs "})}),Object(p.jsx)("li",{class:"navigation-item",children:Object(p.jsx)("a",{href:"#Others",class:"navigation-link",children:" Links "})})]}),Object(p.jsx)("div",{class:"copyright",children:Object(p.jsx)("p",{children:"\xa9 2021 CoreCS All Rights Reserved."})})]}),Object(p.jsx)("div",{id:"root-div"})]})};var m,j,b,g,f,v,w=function(n){var i=n.programName,t=n.programCode;return Object(p.jsxs)("div",{children:[Object(p.jsx)("h1",{children:i}),Object(p.jsx)("section",{id:i,children:Object(p.jsx)("pre",{className:"prettyprint lang-cpp",children:t})})]})},k=function(n){var i=n.webLinkName,t=n.webLink;return t.includes("https://")?Object(p.jsx)("div",{class:"label-container label",children:Object(p.jsx)("a",{href:t,class:"navigation-link",target:"_blank",children:i})}):Object(p.jsx)("div",{class:"label-container label",children:Object(p.jsx)("a",{href:t,class:"navigation-link",children:i})})},x=function(n){Object(d.a)(t,n);var i=Object(h.a)(t);function t(){var n;return Object(c.a)(this,t),(n=i.call(this)).state={weblinks:{Fibonacci:"#Fibonacci",CoinChange:"#CoinChange",LIS:"#LIS",HeapSort:"#HeapSort",MergeSort:"#MergeSort",STL:"#STL",Star:"#Star",Parenthesis:"#Parenthesis",Permutations:"#Permutations",Combinations:"#Combinations","Func-Pointers":"#Func-Pointers",Reverse:"#Reverse",Stack:"#Stack",Queue:"#Queue",Strings:"#Strings",GIT:"#GIT",NQueens:"#NQueens",Bash:"#Bash",SRE:"https://github.com/cskarthik22/howtheysre",Netshoot:"https://github.com/cskarthik22/netshoot","DP-1":"https://www.topcoder.com/thrive/articles/dynamic-programming-and-local-memoization-in-competitive-programming","DP-2":"https://www.topcoder.com/thrive/articles/dynamic-programming-and-local-memoization-part-2","DP-3":"https://www.youtube.com/watch?v=P8Xa2BitN3I",FFT:"https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/",Others:"https://github.com/cskarthik22/coding-interview-university","Big-O":"https://github.com/cskarthik22/Notes/blob/master/Books/big-o-cheatsheet.pdf",Entropy:"https://www.youtube.com/watch?v=JnJq3Py0dyM&t=176s",basecs:"https://medium.com/basecs/tagged/data-structures",Docker:"http://docker-saigon.github.io/post/Docker-Internals/",Linux:"https://cheatsheet.dennyzhang.com/cheatsheet-linuxinternals-a4",iNode:"https://www.thegeekstuff.com/2012/01/linux-inodes/","k8s-deploy-strategies":"https://github.com/ContainerSolutions/k8s-deployment-strategies",sysadmin:"https://sysadmincasts.com/","C/C++":"https://github.com/cskarthik22/Notes/tree/master/stanford/C/C%26C%2B%2B","Binary Trees":"http://cslibrary.stanford.edu/110/BinaryTrees.html","Algo-01":"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html","Algo-02":"https://visualgo.net/en",ebooks:"https://epdf.pub/search/data+structures","*IMP*":"http://courses.csail.mit.edu/iap/interview/materials.php",PKI:"https://www.youtube.com/watch?v=qXLD2UHq2vk",VPN:"https://www.youtube.com/watch?v=4BfL0UHrzDY",DNS:"https://howdns.works/ep1/",HTTPS:"https://howhttps.works/why-do-we-need-https/","Network-Slides":"http://indigoo.com/","Free Courses":"https://www.openculture.com/computer_science_free_courses",API:"https://www.mulesoft.com/resources/api/what-is-an-api","System Design":"https://cheatsheet.dennyzhang.com/cheatsheet-systemdesign-a4","Leet Code":"https://www.youtube.com/watch?v=U6-X_QOwPcs&list=PLU_sdQYzUj2keVENTP0a5rdykRSgg9Wp-","Secure Web API":"https://github.com/cskarthik22/Notes/tree/master/Security",Memory:"http://cse1.net/recaps/memory.html",Channel9:"https://channel9.msdn.com/Browse/AllContent",JS:"https://bost.ocks.org/mike/algorithms/",P5js:"https://thecodingtrain.com/",Network_Packets_3D:"https://youtu.be/xIuBmOufbls","Codeshare.io":"https://codeshare.io/",WhiteBoard:"https://cocreate.csail.mit.edu/"},programs:{Fibonacci:String.raw(m||(m=Object(o.a)(["\n  int fibo(int n) {\n    if( n==0 || n==1) \n        return 1;\n    return fibo(n-1) + fibo(n-2);\n }\n\n int fibo_dp_bottomup(int n) {\n    /* Effective space utilization, instead of array, just maintain\n       only 2 varaibles */\n    int first = 1;\n    int second = 1;\n    int ans = 0;\n    if (n==0 || n==1)\n        return 1;\n    for(int i=2; i&lt;=n; i++) {\n        ans = second + first;\n        first = second;\n        second = ans;\n    }\n    return ans;\n}\n\nint fibo_dp_topdown(int n, int* dp) {\n    // Memoization = Recursion + lookup table\n    if( n==0 || n==1) {\n        return 1;\n    }\n    if(dp[n]!= -1) {\n        return dp[n];\n    }\n    int ans = fibo_dp_topdown(n-1, dp) +\n              fibo_dp_topdown(n-2, dp);\n    dp[n] = ans;\n    \n    return ans;\n}                \n"]))),LIS:String.raw(j||(j=Object(o.a)(["\nint LIS(int* inputarr, int size) {\n  int* lis_arr = new int[size];\n  for(int i=0; i&lt;size; i++)\n  lis_arr[i]=1;\n  \n  for(int i=1; i&lt;size; i++){\n      for(int j=0; j&lt;i; j++) {\n          if(inputarr[i]>inputarr[j] && lis_arr[i] &lt; lis_arr[j]+1) {\n              lis_arr[i] = lis_arr[j]+1;\n          }\n      }\n  }\n  int maxlength= 0;\n  for( int i=0; i&lt;size; i++) {\n      if(lis_arr[i] > maxlength) {\n          maxlength = lis_arr[i];\n      }\n  }\n  delete [] lis_arr;\n  return maxlength;\n}"]))),CoinChange:String.raw(b||(b=Object(o.a)(["\nint coin_change_dp_bottomup(int amount, int* denomintions, int size) {\n  int *ways = new int[amount+1];\n  for(int i=0; i&lt; amount+1; i++) {\n      ways[i] = 0;\n  }\n  ways[0] = 1;\n  for(int i=1; i&lt;size; i++) {\n      for(int j=1; j&lt;amount+1; j++) {\n          if( denomintions[i] &lt;= j ) {\n              ways[j] = ways[j] + ways[j-denomintions[i]];\n          }\n      }\n  }\n  int ans = ways[amount];\n  delete [] ways;\n  return ans;\n};\n\nint coin_change_dp_topdown(int amount, int* denomintions, int size, int** output) {\n  if(amount == 0)\n      return 1;\n  \n  if(amount &lt; 0)\n      return 0;\n  \n  if(size == 0)\n      return 0;\n  \n  if(output[amount][size] &gt; -1)\n      return output[amount][size];\n  \n  int option1 = coin_change_dp_topdown(amount-denomintions[0],denomintions,size,output);\n  int option2 = coin_change_dp_topdown(amount, denomintions+1, size-1, output);\n  output[amount][size] = option1 + option2;\n  \n  return option1 + option2;\n}\n\nint coin_change(int amount, int* denomintions, int size) {\n  \n  if(amount == 0)\n      return 1;\n  \n  if(amount &lt; 0)\n      return 0;\n  \n  if(size == 0)\n      return 0;\n  /*\n   option1: choose first denomination\n   option2: don't choose first denomination\n   */\n  int option1 = coin_change(amount-denomintions[0],denomintions, size);\n  int option2 = coin_change(amount, denomintions+1, size-1);\n  return option1 + option2;\n}"]))),HeapSort:String.raw(g||(g=Object(o.a)(['\n#include &lt;bits/stdc++.h>\nusing namespace std;\n\nvoid swapfunc(vector&lt;pair&lt;double,string>> &vp, int large, int index) {\n    pair&lt;double, string> tp = vp[index];\n    vp[index] = vp[large];\n    vp[large] = tp;\n }\n\nvoid MaxHeapify(vector&lt;pair&lt;double,string>> &vp, int index, int n) {\n    int left = 2*index+1;\n    int right = 2*index+2;\n    int large = index;\n    \n    if(left &lt; n && vp[left].first > vp[index].first) {\n        large = left;\n    } else {\n        large = index;\n    }\n    \n    if(right &lt; n && vp[right].first >vp[large].first) {\n        large = right;\n    }\n    if( large != index) {\n        swapfunc(vp, large, index);\n        MaxHeapify(vp, large, n);\n    }\n}\n\nvoid BuildMapHeap(vector&lt;pair&lt;double,string>> &vp, int n) {\n    for( int i=n/2-1; i>=0; i--) {\n        MaxHeapify(vp, i, n);\n    }\n}\n\nvoid HeapSort(vector&lt;pair&lt;double,string>> &vp, int n) {\n    \n    for( int i=n-1; i>0; i--) {\n        swapfunc(vp, 0, i);\n        MaxHeapify(vp, 0, i);\n    }\n}\n\nint main()\n{\n    vector&lt;pair&lt;double,string>> vp;\n    int n;\n    cin >> n;\n  \n    for( int i=0; i &lt;n; i++) {\n        double item;\n        string name;\n        cin >> item >> name;\n        pair&lt;double,string> p = make_pair(item, name);\n        vp.push_back(p);\n    }\n    \n    cout &lt;&lt; endl;\n    // 1 14 10 8 7 9 3 2 4 6\n    for(auto it = vp.begin(); it != vp.end(); it++){\n        cout &lt;&lt; (*it).first &lt;&lt; " - " &lt;&lt; (*it).second  &lt;&lt; endl;\n    }\n    BuildMapHeap(vp, n);\n    \n    //HeapSort(vp, n);\n    \n    cout &lt;&lt; " Max heap" &lt;&lt; endl;\n    \n    for(auto it = vp.begin(); it != vp.end(); it++){\n        cout &lt;&lt; (*it).first << " - " &lt;&lt; (*it).second  &lt;&lt; endl;\n    }\n\n    return 0;\n}\n/*\n5                    \n1 one                        \n4 four                        \n2 two                       \n5 five                       \n3 three\n*/']))),STL:String.raw(f||(f=Object(o.a)(['\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <forward_list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <tuple>\nusing namespace std;\n\n/*\nlist - doublelinked list\nforward-list - single linked list\n*/\n\nvoid display(vector<int> &v){\n    cout << "vector display" << endl;\n    auto it = v.begin();\n    while(it != v.end()){\n        cout << *it << " ";\n        it++;\n    }\n    cout << endl;\n}\n\nvoid display_list(list<int> &v){\n    cout << "list display" << endl;\n    list<int>::iterator it;\n    it = v.begin();\n    while(it != v.end()){\n        cout << *it << " ";\n        it++;\n    }\n    cout << endl;\n}\n\nvoid display_forard_list(forward_list<int> &v){\n    cout << "forward_list display" << endl;\n    forward_list<int>::iterator it;\n    it = v.begin();\n    while(it != v.end()){\n        cout << *it << " ";\n        it++;\n    }\n    cout << endl;\n}\n\nint main()\n{\n    vector<int> v = { 1,2,10,23,12 };\n    v.push_back(25);\n    display(v);\n    v.pop_back();\n    display(v);\n    \n    list<int> l = { 1,2,10,23,12 };\n    l.push_back(25);\n    display_list(l);\n    \n    forward_list<int> fl = { 1,2,10,23,12 };\n    fl.push_front(25);\n    display_forard_list(fl);\n    \n    \n    stack<int> s;\n    s.push(100);\n    s.push(200);\n    s.push(250);\n    while(!(s.empty())) {\n        cout << s.top() << " ";\n        s.pop();\n    }\n    cout << endl;\n    \n    queue<int> q;\n    q.push(100);\n    q.push(200);\n    q.push(250);\n    while(!(q.empty())){\n        cout << q.front() << " ";\n        q.pop();\n    }\n    cout << endl;\n    \n    pair<int,string> p;\n    p = make_pair(10, "john");\n    cout << p.first << p.second << endl;\n    \n    vector<pair<int,string>> vp;\n    vp.push_back(make_pair(1,"one"));\n    vp.push_back(make_pair(2,"two"));\n    vp.push_back(make_pair(3,"three"));\n    \n    for(auto it = vp.begin(); it != vp.end(); it++){\n        cout << (*it).first << " " << (*it).second << endl;\n    }\n    \n    tuple<int, string, int> t;\n    t = make_tuple(10, "john", 35);\n    cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;\n    \n    vector<tuple<int,string,int>> vt;\n    vt.push_back(make_tuple(10, "john", 35));\n    vt.push_back(make_tuple(20, "mike", 55));\n    vt.push_back(make_tuple(30, "carl", 45));\n    \n    for(auto it=vt.begin(); it!=vt.end(); it++){\n        cout << get<0>(*it) << " " << get<1>(*it) << " " << get<2>(*it) << endl;\n    }\n    \n    priority_queue<pair<int,string>> pq;\n    pq.push(make_pair(10,"john"));\n    pq.push(make_pair(30,"carl"));\n    pq.push(make_pair(20,"mike"));\n    \n    while(!(pq.empty())){\n        cout << pq.top().first << " " << pq.top().second << endl;\n        pq.pop();\n    }\n    \n    return 0;\n}']))),MergeSort:String.raw(v||(v=Object(o.a)(['\n#include <stdio.h>\n    #include <stdlib.h>\n    \n    void Merge(int *arr, int low, int mid, int high) {\n        int n1 = mid - low + 1;\n        int n2 = high - mid;\n        \n        int arr1[n1],arr2[n2];\n        int i,j,k=0;\n        \n        for(i=0;i<n1;i++)\n           arr1[i]=arr[low+i];\n        for(j=0;j<n2;j++)\n          arr2[j]=arr[mid+1+j];\n          i=0;\n          j=0;\n          k=low;\n          while(i<n1 && j<n2) {\n              if(arr1[i]<=arr2[j]) \n                  arr[k++]=arr1[i++];\n              else \n                  arr[k++] = arr2[j++];\n          }\n          while(i<n1){\n              arr[k++] = arr1[i++];\n          }\n          while(j<n2){\n              arr[k++] = arr2[j++];\n          }\n        //printf("done...");\n    }\n    \n    void MergeSort(int *arr,int low, int high){\n        int mid; \n        if(low<high) {\n            mid = low + (high-low)/2;\n            MergeSort(arr,low,mid);\n            MergeSort(arr,mid+1,high);\n            Merge(arr,low,mid,high);\n        }\n    }\n    \n    void Display(int *arr){\n        for(int i=0;arr[i]!=NULL;i++)\n            printf("%d ",arr[i]);\n    }\n    int main()\n    {\n        int A[]={1,14,10,8,7,9,3,2,4,6};\n        int arrlen = sizeof(A)/sizeof(int);\n        Display(&A);\n        printf("\n");\n        MergeSort(&A,0,arrlen-1);\n        Display(&A);\n    }'],['\n#include <stdio.h>\n    #include <stdlib.h>\n    \n    void Merge(int *arr, int low, int mid, int high) {\n        int n1 = mid - low + 1;\n        int n2 = high - mid;\n        \n        int arr1[n1],arr2[n2];\n        int i,j,k=0;\n        \n        for(i=0;i<n1;i++)\n           arr1[i]=arr[low+i];\n        for(j=0;j<n2;j++)\n          arr2[j]=arr[mid+1+j];\n          i=0;\n          j=0;\n          k=low;\n          while(i<n1 && j<n2) {\n              if(arr1[i]<=arr2[j]) \n                  arr[k++]=arr1[i++];\n              else \n                  arr[k++] = arr2[j++];\n          }\n          while(i<n1){\n              arr[k++] = arr1[i++];\n          }\n          while(j<n2){\n              arr[k++] = arr2[j++];\n          }\n        //printf("done...");\n    }\n    \n    void MergeSort(int *arr,int low, int high){\n        int mid; \n        if(low<high) {\n            mid = low + (high-low)/2;\n            MergeSort(arr,low,mid);\n            MergeSort(arr,mid+1,high);\n            Merge(arr,low,mid,high);\n        }\n    }\n    \n    void Display(int *arr){\n        for(int i=0;arr[i]!=NULL;i++)\n            printf("%d ",arr[i]);\n    }\n    int main()\n    {\n        int A[]={1,14,10,8,7,9,3,2,4,6};\n        int arrlen = sizeof(A)/sizeof(int);\n        Display(&A);\n        printf("\\n");\n        MergeSort(&A,0,arrlen-1);\n        Display(&A);\n    }'])))}},n}return Object(l.a)(t,[{key:"render",value:function(){var n=this.state,i=n.programs,t=n.weblinks,e=Object.keys(i),a=Object.keys(t);return Object(p.jsx)(r.a.StrictMode,{children:Object(p.jsxs)("div",{id:"root-div",children:[Object(p.jsx)(u,{}),Object(p.jsx)("header",{className:"header",children:Object(p.jsx)("div",{class:"label-container",children:a.map((function(n){return Object(p.jsx)(k,{webLink:t[n],webLinkName:n})}))})}),Object(p.jsx)("div",{id:"container",children:e.map((function(n){return Object(p.jsx)(w,{programCode:i[n],programName:n})}))})]})})}}]),t}(r.a.Component);s.a.render(Object(p.jsx)(r.a.StrictMode,{children:Object(p.jsx)(x,{})}),document.getElementById("root"))},4:function(n,i,t){},5:function(n,i,t){},6:function(n,i,t){},7:function(n,i,t){}},[[18,1,2]]]);
//# sourceMappingURL=main.d2986d70.chunk.js.map