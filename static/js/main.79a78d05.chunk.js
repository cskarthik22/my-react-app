(this["webpackJsonpmy-react-app"]=this["webpackJsonpmy-react-app"]||[]).push([[0],{12:function(n){n.exports=JSON.parse('{"Fibonacci":"#Fibonacci","CoinChange":"#CoinChange","LIS":"#LIS","HeapSort":"#HeapSort","MergeSort":"#MergeSort","STL":"#STL","Star":"#Star","Parenthesis":"#Parenthesis","Permutations":"#Permutations","Combinations":"#Combinations","Func-Pointers":"#Func-Pointers","Reverse":"#Reverse","Stack":"#Stack","Queue":"#Queue","Strings":"#Strings","GIT":"#GIT","NQueens":"#NQueens","Bash":"#Bash","SRE":"https://github.com/cskarthik22/howtheysre","Netshoot":"https://github.com/cskarthik22/netshoot","DP-1":"https://www.topcoder.com/thrive/articles/dynamic-programming-and-local-memoization-in-competitive-programming","DP-2":"https://www.topcoder.com/thrive/articles/dynamic-programming-and-local-memoization-part-2","DP-3":"https://www.youtube.com/watch?v=P8Xa2BitN3I","FFT":"https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/","Others":"https://github.com/cskarthik22/coding-interview-university","Big-O":"https://github.com/cskarthik22/Notes/blob/master/Books/big-o-cheatsheet.pdf","Entropy":"https://www.youtube.com/watch?v=JnJq3Py0dyM&t=176s","basecs":"https://medium.com/basecs/tagged/data-structures","Docker":"http://docker-saigon.github.io/post/Docker-Internals/","Linux":"https://cheatsheet.dennyzhang.com/cheatsheet-linuxinternals-a4","iNode":"https://www.thegeekstuff.com/2012/01/linux-inodes/","k8s-deploy-strategies":"https://github.com/ContainerSolutions/k8s-deployment-strategies","sysadmin":"https://sysadmincasts.com/","C/C++":"https://github.com/cskarthik22/Notes/tree/master/stanford/C/C%26C%2B%2B","Binary Trees":"http://cslibrary.stanford.edu/110/BinaryTrees.html","Algo-01":"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html","Algo-02":"https://visualgo.net/en","ebooks":"https://epdf.pub/search/data+structures","*IMP*":"http://courses.csail.mit.edu/iap/interview/materials.php","PKI":"https://www.youtube.com/watch?v=qXLD2UHq2vk","VPN":"https://www.youtube.com/watch?v=4BfL0UHrzDY","DNS":"https://howdns.works/ep1/","HTTPS":"https://howhttps.works/why-do-we-need-https/","Network-Slides":"http://indigoo.com/","Free Courses":"https://www.openculture.com/computer_science_free_courses","API":"https://www.mulesoft.com/resources/api/what-is-an-api","System Design":"https://cheatsheet.dennyzhang.com/cheatsheet-systemdesign-a4","Leet Code":"https://www.youtube.com/watch?v=U6-X_QOwPcs&list=PLU_sdQYzUj2keVENTP0a5rdykRSgg9Wp-","Secure Web API":"https://github.com/cskarthik22/Notes/tree/master/Security","Memory":"http://cse1.net/recaps/memory.html","Channel9":"https://channel9.msdn.com/Browse/AllContent","JS":"https://bost.ocks.org/mike/algorithms/","P5js":"https://thecodingtrain.com/","Network_Packets_3D":"https://youtu.be/xIuBmOufbls","Codeshare.io":"https://codeshare.io/","WhiteBoard":"https://cocreate.csail.mit.edu/","KataCoda":"https://katacoda.com/","RedhatLabs":"https://lab.redhat.com"}')},20:function(n,t,e){"use strict";e.r(t);var i=e(2),s=e.n(i),r=e(9),a=e.n(r),o=(e(5),e(6),e(7),e(8),e(1)),l=e(10),c=e(11),d=e(14),p=e(13),h=e(0);var u=function(){return Object(h.jsxs)("div",{class:"navbar",children:[Object(h.jsx)("input",{type:"checkbox",id:"click",class:"checkbox",hidden:!0}),Object(h.jsxs)("div",{class:"sidebar",children:[Object(h.jsx)("label",{for:"click",children:Object(h.jsxs)("div",{class:"menu-icon",children:[Object(h.jsx)("div",{class:"line line-1"}),Object(h.jsx)("div",{class:"line line-2"}),Object(h.jsx)("div",{class:"line line-3"})]})}),Object(h.jsxs)("ul",{class:"social-media-list",children:[Object(h.jsxs)("li",{children:[" ",Object(h.jsx)("a",{href:"https://www.facebook.com/karthik.kaluvala.1/",class:"social-link",children:Object(h.jsx)("i",{class:"fab fa-facebook-f"})})]}),Object(h.jsxs)("li",{children:[" ",Object(h.jsx)("a",{href:"https://linkedin.com/in/cskarthik22",class:"social-link",children:Object(h.jsx)("i",{class:"fab fa-linkedin-in"})})]}),Object(h.jsxs)("li",{children:[" ",Object(h.jsx)("a",{href:"https://twitter.com/cskarthik22",class:"social-link",children:Object(h.jsx)("i",{class:"fab fa-twitter"})})]}),Object(h.jsxs)("li",{children:[" ",Object(h.jsx)("a",{href:"https://www.instagram.com/cskarthik22",class:"social-link",children:Object(h.jsx)("i",{class:"fab fa-instagram"})})]})]})]}),Object(h.jsxs)("nav",{class:"navigation",children:[Object(h.jsxs)("div",{class:"navigation-header",children:[Object(h.jsx)("h1",{class:"navigation-heading",children:" core cs "}),Object(h.jsxs)("form",{class:"navigation-search",children:[Object(h.jsx)("input",{type:"text",class:"naviation-search-input",placeholder:"Search..."}),Object(h.jsx)("button",{class:"navigation-search-btn",children:Object(h.jsx)("i",{class:"fas fa-search"})})]})]}),Object(h.jsxs)("ul",{class:"navigation-list",children:[Object(h.jsx)("li",{class:"navigation-item",children:Object(h.jsx)("a",{href:"#",class:"navigation-link",children:" home "})}),Object(h.jsx)("li",{class:"navigation-item",children:Object(h.jsx)("a",{href:"#",class:"navigation-link",children:" Sorting "})}),Object(h.jsx)("li",{class:"navigation-item",children:Object(h.jsx)("a",{href:"#",class:"navigation-link",children:" Divide-Conquer "})}),Object(h.jsx)("li",{class:"navigation-item",children:Object(h.jsx)("a",{href:"#",class:"navigation-link",children:" Greedy "})}),Object(h.jsx)("li",{class:"navigation-item",children:Object(h.jsx)("a",{href:"#",class:"navigation-link",children:" Backtracking "})}),Object(h.jsx)("li",{class:"navigation-item",children:Object(h.jsx)("a",{href:"#",class:"navigation-link",children:" Recursion "})}),Object(h.jsx)("li",{class:"navigation-item",children:Object(h.jsx)("a",{href:"#",class:"navigation-link",children:" DP (Bitmask) "})}),Object(h.jsx)("li",{class:"navigation-item",children:Object(h.jsx)("a",{href:"#",class:"navigation-link",children:" Graphs "})}),Object(h.jsx)("li",{class:"navigation-item",children:Object(h.jsx)("a",{href:"#Others",class:"navigation-link",children:" Links "})})]}),Object(h.jsx)("div",{class:"copyright",children:Object(h.jsx)("p",{children:"\xa9 2021 CoreCS All Rights Reserved."})})]}),Object(h.jsx)("div",{id:"root-div"})]})},m=function(n){var t=n.programName,e=n.programCode;return Object(h.jsxs)("div",{children:[Object(h.jsx)("h1",{children:t}),Object(h.jsx)("section",{id:t,children:Object(h.jsx)("pre",{className:"prettyprint lang-cpp",children:e})})]})},f=function(n){var t=n.webLinkName,e=n.webLink;return e.includes("https://")?Object(h.jsx)("div",{class:"label-container label",children:Object(h.jsx)("a",{href:e,class:"navigation-link",target:"_blank",children:t})}):Object(h.jsx)("div",{class:"label-container label",children:Object(h.jsx)("a",{href:e,class:"navigation-link",children:t})})},b=e(12),g=e(3),w=e.n(g);var v=function(){var n,t,e,i=[],s=20,r=[];function a(e,i){return e<0||i<0||e>t-1||i>n-1?-1:i+e*n}function o(n,t,e){this.i=t,this.j=e,this.p5=n,this.walls=[!0,!0,!0,!0],this.visited=!1,this.checkneighbors=function(){var s=[],r=i[a(t,e-1)],o=i[a(t+1,e)],l=i[a(t,e+1)],c=i[a(t-1,e)];return r&&!r.visited&&s.push(r),o&&!o.visited&&s.push(o),l&&!l.visited&&s.push(l),c&&!c.visited&&s.push(c),s.length>0?s[n.floor(n.random(0,s.length))]:void 0},this.highlight=function(){var t=this.i*s,e=this.j*s;n.noStroke(),n.fill(0,0,255,100),n.rect(t,e,s,s)},this.show=function(){var t=this.i*s,e=this.j*s;n.stroke(255),this.walls[0]&&n.line(t,e,t+s,e),this.walls[1]&&n.line(t+s,e,t+s,e+s),this.walls[2]&&n.line(t+s,e+s,t,e+s),this.walls[3]&&n.line(t,e+s,t,e),this.visited&&(n.noStroke(),n.fill(255,0,255,10),n.rect(t,e,s,s))}}return Object(h.jsx)(w.a,{setup:function(r,a){r.createCanvas(400,400).parent(a),n=r.floor(r.width/s),t=r.floor(r.height/s);for(var l=0;l<t;l++)for(var c=0;c<n;c++){var d=new o(r,l,c);i.push(d)}r.frameRate(100),e=i[0]},draw:function(n){n.background(100);for(var t=0;t<i.length;t++)i[t].show();e.visited=!0,e.highlight();var s=e.checkneighbors();s?(s.visted=!0,r.push(e),function(n,t){var e=n.i-t.i,i=n.j-t.j;1===e?(n.walls[3]=!1,t.walls[1]=!1):-1===e&&(n.walls[1]=!1,t.walls[3]=!1);1===i?(n.walls[0]=!1,t.walls[2]=!1):-1===i&&(n.walls[2]=!1,t.walls[0]=!1)}(e,s),e=s):r.length>0&&(e=r.pop())}})};var j,y,A,k,x,O,S,T,E,N,R,P,L,_,C,U,B,I,D=function(){var n=[],t=0,e=0;return Object(h.jsx)(w.a,{setup:function(t,e){t.createCanvas(800,500).parent(e);for(var i=0;i<t.width;i++)n[i]=t.random(t.height)},draw:function(i){if(i.background(0),t<n.length){for(e=0;e<n.length-1-t;e++)if(n[e-1]>n[e]){var s=n[e-1];n[e-1]=n[e],n[e]=s}t++}else console.log("i = "+t),i.noLoop(),t=0;for(var r=0;r<n.length;r++)i.stroke(255),i.line(r,i.height,r,i.height-n[r])}})},F=function(n){Object(d.a)(e,n);var t=Object(p.a)(e);function e(){var n;return Object(l.a)(this,e),(n=t.call(this)).state={webLinks1:b,weblinks:{Fibonacci:"#Fibonacci",CoinChange:"#CoinChange",LIS:"#LIS",HeapSort:"#HeapSort",MergeSort:"#MergeSort",STL:"#STL",Star:"#Star",Parenthesis:"#Parenthesis",Permutations:"#Permutations",Combinations:"#Combinations","Func-Pointers":"#Func-Pointers",Reverse:"#Reverse",Stack:"#Stack",Queue:"#Queue",Strings:"#Strings",GIT:"#GIT",NQueens:"#NQueens",Bash:"#Bash",SRE:"https://github.com/cskarthik22/howtheysre",Netshoot:"https://github.com/cskarthik22/netshoot","DP-1":"https://www.topcoder.com/thrive/articles/dynamic-programming-and-local-memoization-in-competitive-programming","DP-2":"https://www.topcoder.com/thrive/articles/dynamic-programming-and-local-memoization-part-2","DP-3":"https://www.youtube.com/watch?v=P8Xa2BitN3I",FFT:"https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/",Others:"https://github.com/cskarthik22/coding-interview-university","Big-O":"https://github.com/cskarthik22/Notes/blob/master/Books/big-o-cheatsheet.pdf",Entropy:"https://www.youtube.com/watch?v=JnJq3Py0dyM&t=176s",basecs:"https://medium.com/basecs/tagged/data-structures",Docker:"http://docker-saigon.github.io/post/Docker-Internals/",Linux:"https://cheatsheet.dennyzhang.com/cheatsheet-linuxinternals-a4",iNode:"https://www.thegeekstuff.com/2012/01/linux-inodes/","k8s-deploy-strategies":"https://github.com/ContainerSolutions/k8s-deployment-strategies",sysadmin:"https://sysadmincasts.com/","C/C++":"https://github.com/cskarthik22/Notes/tree/master/stanford/C/C%26C%2B%2B","Binary Trees":"http://cslibrary.stanford.edu/110/BinaryTrees.html","Algo-01":"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html","Algo-02":"https://visualgo.net/en",ebooks:"https://epdf.pub/search/data+structures","*IMP*":"http://courses.csail.mit.edu/iap/interview/materials.php",PKI:"https://www.youtube.com/watch?v=qXLD2UHq2vk",VPN:"https://www.youtube.com/watch?v=4BfL0UHrzDY",DNS:"https://howdns.works/ep1/",HTTPS:"https://howhttps.works/why-do-we-need-https/","Network-Slides":"http://indigoo.com/","Free Courses":"https://www.openculture.com/computer_science_free_courses",API:"https://www.mulesoft.com/resources/api/what-is-an-api","System Design":"https://cheatsheet.dennyzhang.com/cheatsheet-systemdesign-a4","Leet Code":"https://www.youtube.com/watch?v=U6-X_QOwPcs&list=PLU_sdQYzUj2keVENTP0a5rdykRSgg9Wp-","Secure Web API":"https://github.com/cskarthik22/Notes/tree/master/Security",Memory:"http://cse1.net/recaps/memory.html",Channel9:"https://channel9.msdn.com/Browse/AllContent",JS:"https://bost.ocks.org/mike/algorithms/",P5js:"https://thecodingtrain.com/",Network_Packets_3D:"https://youtu.be/xIuBmOufbls","Codeshare.io":"https://codeshare.io/",WhiteBoard:"https://cocreate.csail.mit.edu/",KataCoda:"https://katacoda.com/",RedhatLabs:"https://lab.redhat.com"},programs:{Fibonacci:String.raw(j||(j=Object(o.a)(["\n  int fibo(int n) {\n    if( n==0 || n==1) \n        return 1;\n    return fibo(n-1) + fibo(n-2);\n }\n\n int fibo_dp_bottomup(int n) {\n    /* Effective space utilization, instead of array, just maintain\n       only 2 varaibles */\n    int first = 1;\n    int second = 1;\n    int ans = 0;\n    if (n==0 || n==1)\n        return 1;\n    for(int i=2; i<=n; i++) {\n        ans = second + first;\n        first = second;\n        second = ans;\n    }\n    return ans;\n}\n\nint fibo_dp_topdown(int n, int* dp) {\n    // Memoization = Recursion + lookup table\n    if( n==0 || n==1) {\n        return 1;\n    }\n    if(dp[n]!= -1) {\n        return dp[n];\n    }\n    int ans = fibo_dp_topdown(n-1, dp) +\n              fibo_dp_topdown(n-2, dp);\n    dp[n] = ans;\n    \n    return ans;\n}                \n"]))),LIS:String.raw(y||(y=Object(o.a)(["\nint LIS(int* inputarr, int size) {\n  int* lis_arr = new int[size];\n  for(int i=0; i<size; i++)\n  lis_arr[i]=1;\n  \n  for(int i=1; i<size; i++){\n      for(int j=0; j<i; j++) {\n          if(inputarr[i]>inputarr[j] && lis_arr[i] < lis_arr[j]+1) {\n              lis_arr[i] = lis_arr[j]+1;\n          }\n      }\n  }\n  int maxlength= 0;\n  for( int i=0; i<size; i++) {\n      if(lis_arr[i] > maxlength) {\n          maxlength = lis_arr[i];\n      }\n  }\n  delete [] lis_arr;\n  return maxlength;\n}"]))),CoinChange:String.raw(A||(A=Object(o.a)(["\nint coin_change_dp_bottomup(int amount, int* denomintions, int size) {\n  int *ways = new int[amount+1];\n  for(int i=0; i< amount+1; i++) {\n      ways[i] = 0;\n  }\n  ways[0] = 1;\n  for(int i=1; i<size; i++) {\n      for(int j=1; j<amount+1; j++) {\n          if( denomintions[i] <= j ) {\n              ways[j] = ways[j] + ways[j-denomintions[i]];\n          }\n      }\n  }\n  int ans = ways[amount];\n  delete [] ways;\n  return ans;\n};\n\nint coin_change_dp_topdown(int amount, int* denomintions, int size, int** output) {\n  if(amount == 0)\n      return 1;\n  \n  if(amount < 0)\n      return 0;\n  \n  if(size == 0)\n      return 0;\n  \n  if(output[amount][size] &gt; -1)\n      return output[amount][size];\n  \n  int option1 = coin_change_dp_topdown(amount-denomintions[0],denomintions,size,output);\n  int option2 = coin_change_dp_topdown(amount, denomintions+1, size-1, output);\n  output[amount][size] = option1 + option2;\n  \n  return option1 + option2;\n}\n\nint coin_change(int amount, int* denomintions, int size) {\n  \n  if(amount == 0)\n      return 1;\n  \n  if(amount < 0)\n      return 0;\n  \n  if(size == 0)\n      return 0;\n  /*\n   option1: choose first denomination\n   option2: don't choose first denomination\n   */\n  int option1 = coin_change(amount-denomintions[0],denomintions, size);\n  int option2 = coin_change(amount, denomintions+1, size-1);\n  return option1 + option2;\n}"]))),HeapSort:String.raw(k||(k=Object(o.a)(['\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid swapfunc(vector<pair<double,string>> &vp, int large, int index) {\n    pair<double, string> tp = vp[index];\n    vp[index] = vp[large];\n    vp[large] = tp;\n }\n\nvoid MaxHeapify(vector<pair<double,string>> &vp, int index, int n) {\n    int left = 2*index+1;\n    int right = 2*index+2;\n    int large = index;\n    \n    if(left < n && vp[left].first > vp[index].first) {\n        large = left;\n    } else {\n        large = index;\n    }\n    \n    if(right < n && vp[right].first >vp[large].first) {\n        large = right;\n    }\n    if( large != index) {\n        swapfunc(vp, large, index);\n        MaxHeapify(vp, large, n);\n    }\n}\n\nvoid BuildMapHeap(vector<pair<double,string>> &vp, int n) {\n    for( int i=n/2-1; i>=0; i--) {\n        MaxHeapify(vp, i, n);\n    }\n}\n\nvoid HeapSort(vector<pair<double,string>> &vp, int n) {\n    \n    for( int i=n-1; i>0; i--) {\n        swapfunc(vp, 0, i);\n        MaxHeapify(vp, 0, i);\n    }\n}\n\nint main()\n{\n    vector<pair<double,string>> vp;\n    int n;\n    cin >> n;\n  \n    for( int i=0; i <n; i++) {\n        double item;\n        string name;\n        cin >> item >> name;\n        pair<double,string> p = make_pair(item, name);\n        vp.push_back(p);\n    }\n    \n    cout << endl;\n    // 1 14 10 8 7 9 3 2 4 6\n    for(auto it = vp.begin(); it != vp.end(); it++){\n        cout << (*it).first << " - " << (*it).second  << endl;\n    }\n    BuildMapHeap(vp, n);\n    \n    //HeapSort(vp, n);\n    \n    cout << " Max heap" << endl;\n    \n    for(auto it = vp.begin(); it != vp.end(); it++){\n        cout << (*it).first << " - " << (*it).second  << endl;\n    }\n\n    return 0;\n}\n/*\n5                    \n1 one                        \n4 four                        \n2 two                       \n5 five                       \n3 three\n*/']))),STL:String.raw(x||(x=Object(o.a)(['\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <forward_list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <tuple>\nusing namespace std;\n\n/*\nlist - doublelinked list\nforward-list - single linked list\n*/\n\nvoid display(vector<int> &v){\n    cout << "vector display" << endl;\n    auto it = v.begin();\n    while(it != v.end()){\n        cout << *it << " ";\n        it++;\n    }\n    cout << endl;\n}\n\nvoid display_list(list<int> &v){\n    cout << "list display" << endl;\n    list<int>::iterator it;\n    it = v.begin();\n    while(it != v.end()){\n        cout << *it << " ";\n        it++;\n    }\n    cout << endl;\n}\n\nvoid display_forard_list(forward_list<int> &v){\n    cout << "forward_list display" << endl;\n    forward_list<int>::iterator it;\n    it = v.begin();\n    while(it != v.end()){\n        cout << *it << " ";\n        it++;\n    }\n    cout << endl;\n}\n\nint main()\n{\n    vector<int> v = { 1,2,10,23,12 };\n    v.push_back(25);\n    display(v);\n    v.pop_back();\n    display(v);\n    \n    list<int> l = { 1,2,10,23,12 };\n    l.push_back(25);\n    display_list(l);\n    \n    forward_list<int> fl = { 1,2,10,23,12 };\n    fl.push_front(25);\n    display_forard_list(fl);\n    \n    \n    stack<int> s;\n    s.push(100);\n    s.push(200);\n    s.push(250);\n    while(!(s.empty())) {\n        cout << s.top() << " ";\n        s.pop();\n    }\n    cout << endl;\n    \n    queue<int> q;\n    q.push(100);\n    q.push(200);\n    q.push(250);\n    while(!(q.empty())){\n        cout << q.front() << " ";\n        q.pop();\n    }\n    cout << endl;\n    \n    pair<int,string> p;\n    p = make_pair(10, "john");\n    cout << p.first << p.second << endl;\n    \n    vector<pair<int,string>> vp;\n    vp.push_back(make_pair(1,"one"));\n    vp.push_back(make_pair(2,"two"));\n    vp.push_back(make_pair(3,"three"));\n    \n    for(auto it = vp.begin(); it != vp.end(); it++){\n        cout << (*it).first << " " << (*it).second << endl;\n    }\n    \n    tuple<int, string, int> t;\n    t = make_tuple(10, "john", 35);\n    cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;\n    \n    vector<tuple<int,string,int>> vt;\n    vt.push_back(make_tuple(10, "john", 35));\n    vt.push_back(make_tuple(20, "mike", 55));\n    vt.push_back(make_tuple(30, "carl", 45));\n    \n    for(auto it=vt.begin(); it!=vt.end(); it++){\n        cout << get<0>(*it) << " " << get<1>(*it) << " " << get<2>(*it) << endl;\n    }\n    \n    priority_queue<pair<int,string>> pq;\n    pq.push(make_pair(10,"john"));\n    pq.push(make_pair(30,"carl"));\n    pq.push(make_pair(20,"mike"));\n    \n    while(!(pq.empty())){\n        cout << pq.top().first << " " << pq.top().second << endl;\n        pq.pop();\n    }\n    \n    return 0;\n}']))),MergeSort:String.raw(O||(O=Object(o.a)(['\n#include <stdio.h>\n    #include <stdlib.h>\n    \n    void Merge(int *arr, int low, int mid, int high) {\n        int n1 = mid - low + 1;\n        int n2 = high - mid;\n        \n        int arr1[n1],arr2[n2];\n        int i,j,k=0;\n        \n        for(i=0;i<n1;i++)\n           arr1[i]=arr[low+i];\n        for(j=0;j<n2;j++)\n          arr2[j]=arr[mid+1+j];\n          i=0;\n          j=0;\n          k=low;\n          while(i<n1 && j<n2) {\n              if(arr1[i]<=arr2[j]) \n                  arr[k++]=arr1[i++];\n              else \n                  arr[k++] = arr2[j++];\n          }\n          while(i<n1){\n              arr[k++] = arr1[i++];\n          }\n          while(j<n2){\n              arr[k++] = arr2[j++];\n          }\n        //printf("done...");\n    }\n    \n    void MergeSort(int *arr,int low, int high){\n        int mid; \n        if(low<high) {\n            mid = low + (high-low)/2;\n            MergeSort(arr,low,mid);\n            MergeSort(arr,mid+1,high);\n            Merge(arr,low,mid,high);\n        }\n    }\n    \n    void Display(int *arr){\n        for(int i=0;arr[i]!=NULL;i++)\n            printf("%d ",arr[i]);\n    }\n    int main()\n    {\n        int A[]={1,14,10,8,7,9,3,2,4,6};\n        int arrlen = sizeof(A)/sizeof(int);\n        Display(&A);\n        printf("\n");\n        MergeSort(&A,0,arrlen-1);\n        Display(&A);\n    }'],['\n#include <stdio.h>\n    #include <stdlib.h>\n    \n    void Merge(int *arr, int low, int mid, int high) {\n        int n1 = mid - low + 1;\n        int n2 = high - mid;\n        \n        int arr1[n1],arr2[n2];\n        int i,j,k=0;\n        \n        for(i=0;i<n1;i++)\n           arr1[i]=arr[low+i];\n        for(j=0;j<n2;j++)\n          arr2[j]=arr[mid+1+j];\n          i=0;\n          j=0;\n          k=low;\n          while(i<n1 && j<n2) {\n              if(arr1[i]<=arr2[j]) \n                  arr[k++]=arr1[i++];\n              else \n                  arr[k++] = arr2[j++];\n          }\n          while(i<n1){\n              arr[k++] = arr1[i++];\n          }\n          while(j<n2){\n              arr[k++] = arr2[j++];\n          }\n        //printf("done...");\n    }\n    \n    void MergeSort(int *arr,int low, int high){\n        int mid; \n        if(low<high) {\n            mid = low + (high-low)/2;\n            MergeSort(arr,low,mid);\n            MergeSort(arr,mid+1,high);\n            Merge(arr,low,mid,high);\n        }\n    }\n    \n    void Display(int *arr){\n        for(int i=0;arr[i]!=NULL;i++)\n            printf("%d ",arr[i]);\n    }\n    int main()\n    {\n        int A[]={1,14,10,8,7,9,3,2,4,6};\n        int arrlen = sizeof(A)/sizeof(int);\n        Display(&A);\n        printf("\\n");\n        MergeSort(&A,0,arrlen-1);\n        Display(&A);\n    }']))),Star:String.raw(S||(S=Object(o.a)(['\n#include <stdio.h>\n\nint main()\n{\n    int n=10;\n    \n    for(int i=1; i<=n;i++){\n        int spaces = n-i;\n        for(int j = 1; j<=2*spaces; j++) printf(" "); //first in row\n        for(int j = 1; j<=i; j++) printf("   A"); // middle in row\n        for(int j = 1; j<=2*spaces; j++) printf(" "); // last in row\n        printf("\n");\n    }\n    for(int i=n-1; i>=1;i--){\n        int spaces = n-i;\n        for(int j = 1; j<=2*spaces; j++) printf(" ");\n        for(int j = 1; j<=i; j++) printf("   A");\n        for(int j = 1; j<=2*spaces; j++) printf(" ");\n        printf("\n");\n    }\n    \n\n    return 0;\n}\n\n/*\noutput:\n\n                     A                                                                                                                                           \n                   A   A                                                                                                                                         \n                 A   A   A                                                                                                                                       \n               A   A   A   A                                                                                                                                     \n             A   A   A   A   A                                                                                                                                   \n           A   A   A   A   A   A                                                                                                                                 \n         A   A   A   A   A   A   A                                                                                                                               \n       A   A   A   A   A   A   A   A                                                                                                                             \n     A   A   A   A   A   A   A   A   A                                                                                                                           \n   A   A   A   A   A   A   A   A   A   A                                                                                                                         \n     A   A   A   A   A   A   A   A   A                                                                                                                           \n       A   A   A   A   A   A   A   A                                                                                                                             \n         A   A   A   A   A   A   A                                                                                                                               \n           A   A   A   A   A   A                                                                                                                                 \n             A   A   A   A   A                                                                                                                                   \n               A   A   A   A                                                                                                                                     \n                 A   A   A                                                                                                                                       \n                   A   A                                                                                                                                         \n                     A                                             \n*/\n    '],['\n#include <stdio.h>\n\nint main()\n{\n    int n=10;\n    \n    for(int i=1; i<=n;i++){\n        int spaces = n-i;\n        for(int j = 1; j<=2*spaces; j++) printf(" "); //first in row\n        for(int j = 1; j<=i; j++) printf("   A"); // middle in row\n        for(int j = 1; j<=2*spaces; j++) printf(" "); // last in row\n        printf("\\n");\n    }\n    for(int i=n-1; i>=1;i--){\n        int spaces = n-i;\n        for(int j = 1; j<=2*spaces; j++) printf(" ");\n        for(int j = 1; j<=i; j++) printf("   A");\n        for(int j = 1; j<=2*spaces; j++) printf(" ");\n        printf("\\n");\n    }\n    \n\n    return 0;\n}\n\n/*\noutput:\n\n                     A                                                                                                                                           \n                   A   A                                                                                                                                         \n                 A   A   A                                                                                                                                       \n               A   A   A   A                                                                                                                                     \n             A   A   A   A   A                                                                                                                                   \n           A   A   A   A   A   A                                                                                                                                 \n         A   A   A   A   A   A   A                                                                                                                               \n       A   A   A   A   A   A   A   A                                                                                                                             \n     A   A   A   A   A   A   A   A   A                                                                                                                           \n   A   A   A   A   A   A   A   A   A   A                                                                                                                         \n     A   A   A   A   A   A   A   A   A                                                                                                                           \n       A   A   A   A   A   A   A   A                                                                                                                             \n         A   A   A   A   A   A   A                                                                                                                               \n           A   A   A   A   A   A                                                                                                                                 \n             A   A   A   A   A                                                                                                                                   \n               A   A   A   A                                                                                                                                     \n                 A   A   A                                                                                                                                       \n                   A   A                                                                                                                                         \n                     A                                             \n*/\n    ']))),Permutations:String.raw(T||(T=Object(o.a)(['\n// Program to permute a given string \n\n/*    \n Permutations: Deals with selection + arrangement.\n Example: select 11 out of 20 players in a cricket team and also decide batting arrangement.\n Answer: nPr => nCr * r! ==> n!/(n-r)!\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint count=0;\nchar letters[] = "abc";\nint *visited;\nvoid permuatations(char *str, int start, int end)\n{\n    if(start == end) {\n        printf("%s ", str);\n        count++;\n    } else {\n        for(int i=0;i<strlen(letters); i++) {\n            if(visited[i]==0) {\n                str[start] = letters[i];\n                visited[i] = 1;\n                permuatations(str, start+1, end);\n                visited[i] = 0;\n                str[start] = \'\0\';\n            }\n        }\n    }\n}\n\nvoid main() {\n    int n=sizeof(letters);\n    char *input = (char*)calloc(n,sizeof(char));\n    visited = (int *)calloc(n,sizeof(int));\n    permuatations(input,0,n-1);\n    printf("\nTotal permuatations = %d", count);\n}\n\n/* OUTPUT\nabc acb bac bca cab cba                                                                                                                                                                     \nTotal permuatations = 6\n*/\n'],['\n// Program to permute a given string \n\n/*    \n Permutations: Deals with selection + arrangement.\n Example: select 11 out of 20 players in a cricket team and also decide batting arrangement.\n Answer: nPr => nCr * r! ==> n!/(n-r)!\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint count=0;\nchar letters[] = "abc";\nint *visited;\nvoid permuatations(char *str, int start, int end)\n{\n    if(start == end) {\n        printf("%s ", str);\n        count++;\n    } else {\n        for(int i=0;i<strlen(letters); i++) {\n            if(visited[i]==0) {\n                str[start] = letters[i];\n                visited[i] = 1;\n                permuatations(str, start+1, end);\n                visited[i] = 0;\n                str[start] = \'\\0\';\n            }\n        }\n    }\n}\n\nvoid main() {\n    int n=sizeof(letters);\n    char *input = (char*)calloc(n,sizeof(char));\n    visited = (int *)calloc(n,sizeof(int));\n    permuatations(input,0,n-1);\n    printf("\\nTotal permuatations = %d", count);\n}\n\n/* OUTPUT\nabc acb bac bca cab cba                                                                                                                                                                     \nTotal permuatations = 6\n*/\n']))),Parenthesis:String.raw(E||(E=Object(o.a)(['\n// Generate all valid parenthesis\n#include <stdio.h>\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid genparenthesis(int n, int open, int close, string output){\n    if(output.size()==2*n)\n       cout << output << endl;\n    \n    if(open<n)\n       genparenthesis(n,open+1,close, output + "(");\n       \n    if(close<open)\n       genparenthesis(n,open,close+1, output + ")");\n    \n}\n\nint main()\n{\n  genparenthesis(3,0,0,"");\n  return 0;\n}\n\n/* OUTPUT:\n          ((()))       \n          (()())                        \n          (())()                       \n          ()(())                        \n          ()()()\n\n*/\n']))),"Func-Pointers":String.raw(N||(N=Object(o.a)(['\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef void (*Funstr)(char *);\n\nvoid strLength(char *s) { \n  int i;\n  for (i = 0; s[i] != \'\0\'; i++);\n  printf ("strLength = %d", i);\n}\n\nvoid strUpper(char *s) {\n  for (int i = 0; s[i] != \'\0\'; i++) {\n    if (s[i] >= 97 && s[i] <= 122) {\n       s[i] = s[i] - 32;\n    }\n  }\n  printf ("\nUpper = %s", s);\n}\n\nvoid strLower(char *s) { \n  for (int i = 0; s[i] != \'\0\'; i++) {\n    if (s[i] >= 65 && s[i] <= 90) {\n\t   s[i] = s[i] + 32;\n\t}\n  }\n  printf ("\nLower = %s ", s);\n}\n\nvoid swap(char *a, char *b) {\n    *a = *a ^ *b;\n    *b = *a ^ *b;\n    *a = *a ^ *b;\n}\n\nvoid strReverse(char *s) {\n    \n    for(int i=0,j=strlen(s)-1;i<j;i++,j--)\n       swap(&s[i], &s[j]);\n    printf ("\nReverse = %s ", s);\n}\n\nvoid IsPalindrome(char *s) {\n    for(int i=0,j=strlen(s)-1;i<j;i++,j--) {\n        if (s[i] != s[j]) {\n            printf("%s is not a palindrome");\n            return;\n        }\n    }\n    printf("\n%s is a palindrome", s);\n    \n}\n\nint main()\n{\n    char str1[] = "WeLcome" , str2[] = "madam";\n    \n    Funstr strOperations[] = { strLength, strUpper, strLower, strReverse, IsPalindrome };\n    strOperations[0](str1);\n    strOperations[1](str1);\n    strOperations[2](str1);\n    strOperations[3](str1);\n    strOperations[4](str1); strOperations[4](str2);\n    \n\n    return 0;\n}'],['\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef void (*Funstr)(char *);\n\nvoid strLength(char *s) { \n  int i;\n  for (i = 0; s[i] != \'\\0\'; i++);\n  printf ("strLength = %d", i);\n}\n\nvoid strUpper(char *s) {\n  for (int i = 0; s[i] != \'\\0\'; i++) {\n    if (s[i] >= 97 && s[i] <= 122) {\n       s[i] = s[i] - 32;\n    }\n  }\n  printf ("\\nUpper = %s", s);\n}\n\nvoid strLower(char *s) { \n  for (int i = 0; s[i] != \'\\0\'; i++) {\n    if (s[i] >= 65 && s[i] <= 90) {\n\t   s[i] = s[i] + 32;\n\t}\n  }\n  printf ("\\nLower = %s ", s);\n}\n\nvoid swap(char *a, char *b) {\n    *a = *a ^ *b;\n    *b = *a ^ *b;\n    *a = *a ^ *b;\n}\n\nvoid strReverse(char *s) {\n    \n    for(int i=0,j=strlen(s)-1;i<j;i++,j--)\n       swap(&s[i], &s[j]);\n    printf ("\\nReverse = %s ", s);\n}\n\nvoid IsPalindrome(char *s) {\n    for(int i=0,j=strlen(s)-1;i<j;i++,j--) {\n        if (s[i] != s[j]) {\n            printf("%s is not a palindrome");\n            return;\n        }\n    }\n    printf("\\n%s is a palindrome", s);\n    \n}\n\nint main()\n{\n    char str1[] = "WeLcome" , str2[] = "madam";\n    \n    Funstr strOperations[] = { strLength, strUpper, strLower, strReverse, IsPalindrome };\n    strOperations[0](str1);\n    strOperations[1](str1);\n    strOperations[2](str1);\n    strOperations[3](str1);\n    strOperations[4](str1); strOperations[4](str2);\n    \n\n    return 0;\n}']))),Combinations:String.raw(R||(R=Object(o.a)(['\n/*\n   Combination: Deals with only selection.\n   Example: select 11 out of 20 players in a cricket team\n   Answer: nCr => n!/((n-r)!*r!) => 20C11\n*/\n\n#include <stdio.h>\n\nstatic int count=0;\nvoid swap ( char *a, char *b)\n{\n    char temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid Combinations(char *str, int start, int end)\n{\n    int index;\n   \n    if(start == end)\n    {\n        printf("%s\n", str);\n        count++;\n    }\n    else\n    {\n        for(index = start;index<=end;index++)\n        {\n         swap(&str[start],&str[index]);\n         Combinations(str, start+1, end);\n         swap(&str[start],&str[index]);\n         \n        }\n    }\n   \n}\n\nint main()\n{\n    \n    char input[] = "abc";\n    Combinations(input,0,strlen(input)-1);\n    printf("Total Combinations = %d", count);\n    \n    return 0;\n}\n\n/* OUTPUT:\n\n    abc                      \n    acb                          \n    bac                          \n    bca                          \n    cba                         \n    cab                                                                                                                                                              \n    Total Combinations = 6 \n\n*/'],['\n/*\n   Combination: Deals with only selection.\n   Example: select 11 out of 20 players in a cricket team\n   Answer: nCr => n!/((n-r)!*r!) => 20C11\n*/\n\n#include <stdio.h>\n\nstatic int count=0;\nvoid swap ( char *a, char *b)\n{\n    char temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid Combinations(char *str, int start, int end)\n{\n    int index;\n   \n    if(start == end)\n    {\n        printf("%s\\n", str);\n        count++;\n    }\n    else\n    {\n        for(index = start;index<=end;index++)\n        {\n         swap(&str[start],&str[index]);\n         Combinations(str, start+1, end);\n         swap(&str[start],&str[index]);\n         \n        }\n    }\n   \n}\n\nint main()\n{\n    \n    char input[] = "abc";\n    Combinations(input,0,strlen(input)-1);\n    printf("Total Combinations = %d", count);\n    \n    return 0;\n}\n\n/* OUTPUT:\n\n    abc                      \n    acb                          \n    bac                          \n    bca                          \n    cba                         \n    cab                                                                                                                                                              \n    Total Combinations = 6 \n\n*/']))),Reverse:String.raw(P||(P=Object(o.a)(["\n/*Reverese words in a given string */\n\n/*\nAlgorithm\n=========\n\nstep1: Reverse the individual words\nstep2: Reverse the whole string from start to end\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid reverse(char *start, char *end)\n{\n\tchar temp;\n\twhile(start < end)\n\t{\n\t\ttemp = *start;\n\t\t*start++ = *end;\n\t\t*end-- = temp;\n\t}\n}\n\nvoid RevereseWords(char *str)\n{\n\tchar *wordBegin, *temp;\n\twordBegin = '\0';\n\ttemp = str;\n\t//reverse the individual words\n\twhile(*temp)\n\t{\n\t\tif((wordBegin == '\0') && (*temp != ' '))\n\t\t\twordBegin = temp;\n\t\tif(wordBegin && ((*(temp+1) == ' ') || (*(temp + 1) == '\0')))\n\t\t{\n\t\t\treverse(wordBegin, temp);\n\t\t\twordBegin = '\0';\n\t\t}\n\t\ttemp++;\n\t}\n\t//reverse the whole string from start to end\n\treverse(str, temp-1);\n}\n\nint main()\n{\n\tchar str[100] = \"Welcome to Programming!!\";\n\n\tRevereseWords(str);\n\tprintf(\"%s\n\", str);\n\treturn 0;\n}\n\n/* OUTPUT:\n\n   Programming!! to Welcome\n*/"],["\n/*Reverese words in a given string */\n\n/*\nAlgorithm\n=========\n\nstep1: Reverse the individual words\nstep2: Reverse the whole string from start to end\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid reverse(char *start, char *end)\n{\n\tchar temp;\n\twhile(start < end)\n\t{\n\t\ttemp = *start;\n\t\t*start++ = *end;\n\t\t*end-- = temp;\n\t}\n}\n\nvoid RevereseWords(char *str)\n{\n\tchar *wordBegin, *temp;\n\twordBegin = '\\0';\n\ttemp = str;\n\t//reverse the individual words\n\twhile(*temp)\n\t{\n\t\tif((wordBegin == '\\0') && (*temp != ' '))\n\t\t\twordBegin = temp;\n\t\tif(wordBegin && ((*(temp+1) == ' ') || (*(temp + 1) == '\\0')))\n\t\t{\n\t\t\treverse(wordBegin, temp);\n\t\t\twordBegin = '\\0';\n\t\t}\n\t\ttemp++;\n\t}\n\t//reverse the whole string from start to end\n\treverse(str, temp-1);\n}\n\nint main()\n{\n\tchar str[100] = \"Welcome to Programming!!\";\n\n\tRevereseWords(str);\n\tprintf(\"%s\\n\", str);\n\treturn 0;\n}\n\n/* OUTPUT:\n\n   Programming!! to Welcome\n*/"]))),Stack:String.raw(L||(L=Object(o.a)(['\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node_Block {\n    int data;\n    struct Node_Block *link;\n} node;\n\nnode *TOP = NULL;\n\nvoid push(int item) {\n    // Create a new node\n    node *temp = (node *)malloc(sizeof(node));\n    temp->data = item;\n    temp->link = NULL;\n    \n    if ( TOP == NULL ) {\n       TOP = temp;\n       return;\n    } \n    temp->link = TOP;\n    TOP = temp;\n}\n\nvoid pop() {\n    node *temp;\n    if ( TOP == NULL ) {\n        printf(" Stack is empty \n");\n        return;\n    } \n    temp = TOP;\n    TOP=TOP->link;\n    free(temp);\n}\n\nvoid display() {\n    node *inode = TOP;\n    printf("[ TOP ] => ");\n    while(inode) {\n        printf("[ %d ] =>", inode->data);\n        inode=inode->link;\n    }\n}\n\nvoid print_top() {\n    printf("%d", TOP->data);\n}\n\nint main()\n{\n    printf("\n\t MENU: 1) PUSH 2) POP 3) TOP 4) Display 5) Exit \n");\n    int ch;\n    int item;\n   \n    do {\n        printf("enter your choice(1-5): ");\n        scanf("%d",&ch);\n        \n        switch(ch) {\n            case 1:\n                printf("\n Enter data : ");\n                scanf("%d", &item);\n                push(item);\n                break;\n            case 2:\n                pop();\n                break;\n            case 3:\n                print_top();\n                break;\n            case 4:\n                display();\n                break;\n            case 5:\n                // Free All nodes ( clear heap memory)\n                while(TOP) {\n                    node* temp = TOP;\n                    TOP = TOP->link;\n                    free(temp);\n                    printf("Memory - Cleared \n");\n                }\n                exit(0);\n                \n            default:\n                printf(" Wrong choice ;\n");\n                break;\n            \n        }\n        \n    \n    } while( ch != 5);\n\n    return 0;\n}'],['\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node_Block {\n    int data;\n    struct Node_Block *link;\n} node;\n\nnode *TOP = NULL;\n\nvoid push(int item) {\n    // Create a new node\n    node *temp = (node *)malloc(sizeof(node));\n    temp->data = item;\n    temp->link = NULL;\n    \n    if ( TOP == NULL ) {\n       TOP = temp;\n       return;\n    } \n    temp->link = TOP;\n    TOP = temp;\n}\n\nvoid pop() {\n    node *temp;\n    if ( TOP == NULL ) {\n        printf(" Stack is empty \\n");\n        return;\n    } \n    temp = TOP;\n    TOP=TOP->link;\n    free(temp);\n}\n\nvoid display() {\n    node *inode = TOP;\n    printf("[ TOP ] => ");\n    while(inode) {\n        printf("[ %d ] =>", inode->data);\n        inode=inode->link;\n    }\n}\n\nvoid print_top() {\n    printf("%d", TOP->data);\n}\n\nint main()\n{\n    printf("\\n\\t MENU: 1) PUSH 2) POP 3) TOP 4) Display 5) Exit \\n");\n    int ch;\n    int item;\n   \n    do {\n        printf("enter your choice(1-5): ");\n        scanf("%d",&ch);\n        \n        switch(ch) {\n            case 1:\n                printf("\\n Enter data : ");\n                scanf("%d", &item);\n                push(item);\n                break;\n            case 2:\n                pop();\n                break;\n            case 3:\n                print_top();\n                break;\n            case 4:\n                display();\n                break;\n            case 5:\n                // Free All nodes ( clear heap memory)\n                while(TOP) {\n                    node* temp = TOP;\n                    TOP = TOP->link;\n                    free(temp);\n                    printf("Memory - Cleared \\n");\n                }\n                exit(0);\n                \n            default:\n                printf(" Wrong choice ;\\n");\n                break;\n            \n        }\n        \n    \n    } while( ch != 5);\n\n    return 0;\n}']))),Queue:String.raw(_||(_=Object(o.a)(['\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node_Block {\n    int data;\n    struct Node_Block *link;\n} node;\n\nnode *FRONT, *REAR = NULL;\n\nvoid Enqueue(int item) {\n    \n    node *temp = (node *)malloc(sizeof(node));\n    temp->data = item;\n    temp->link=NULL;\n    \n    if( REAR == NULL) {\n        FRONT = REAR = temp; \n        return;\n    }\n    REAR->link=temp;\n    REAR = temp;\n    return;\n}\n\nvoid Dequeue(){\n    if( (FRONT==NULL) && (REAR==NULL) ) {\n        printf("Queue is empty...");\n    } else \n    if ( FRONT==REAR ) {\n        free(FRONT);\n        FRONT=REAR=NULL;\n    } else {\n        node *temp = FRONT;\n        FRONT=FRONT->link;\n        free(temp);\n    }\n    \n}\n\nvoid Display(){\n    node *seeknode = FRONT;\n    printf("[ FRONT ] => ");\n    while(seeknode) {\n        printf("[ %d ] => ", seeknode->data);\n        seeknode = seeknode->link;\n    }\n    printf("[ REAR ] => ");\n}\n\nvoid Is_Empty(){\n    \n}\n\nvoid main(){\n    \n    int ch, item;\n    node *temp;\n    printf("\n\t MENU 1) Enqueue 2) Dequeue 3) Is_Empty 4) Display 5) Exit... ");\n    do {\n        printf("\n Enter choice ");\n        scanf("%d", &ch);\n        switch(ch) {\n            case 1:\n                printf("\nEnter item ");\n                scanf("%d", &item);\n                Enqueue(item);\n                break;\n            case 2:\n                Dequeue();\n                break;\n            case 3:\n                Is_Empty();\n                break;\n            case 4:\n                Display();\n                break;\n            case 5:\n                // Free All nodes ( clear heap memory)\n                \n                while(FRONT) {\n                    temp = FRONT;\n                    FRONT = FRONT->link;\n                    free(temp);\n                    printf("Memory-Cleared\n");\n                }\n                exit(0);\n            \n        }\n    \n    } while(ch != 5);\n    \n}'],['\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node_Block {\n    int data;\n    struct Node_Block *link;\n} node;\n\nnode *FRONT, *REAR = NULL;\n\nvoid Enqueue(int item) {\n    \n    node *temp = (node *)malloc(sizeof(node));\n    temp->data = item;\n    temp->link=NULL;\n    \n    if( REAR == NULL) {\n        FRONT = REAR = temp; \n        return;\n    }\n    REAR->link=temp;\n    REAR = temp;\n    return;\n}\n\nvoid Dequeue(){\n    if( (FRONT==NULL) && (REAR==NULL) ) {\n        printf("Queue is empty...");\n    } else \n    if ( FRONT==REAR ) {\n        free(FRONT);\n        FRONT=REAR=NULL;\n    } else {\n        node *temp = FRONT;\n        FRONT=FRONT->link;\n        free(temp);\n    }\n    \n}\n\nvoid Display(){\n    node *seeknode = FRONT;\n    printf("[ FRONT ] => ");\n    while(seeknode) {\n        printf("[ %d ] => ", seeknode->data);\n        seeknode = seeknode->link;\n    }\n    printf("[ REAR ] => ");\n}\n\nvoid Is_Empty(){\n    \n}\n\nvoid main(){\n    \n    int ch, item;\n    node *temp;\n    printf("\\n\\t MENU 1) Enqueue 2) Dequeue 3) Is_Empty 4) Display 5) Exit... ");\n    do {\n        printf("\\n Enter choice ");\n        scanf("%d", &ch);\n        switch(ch) {\n            case 1:\n                printf("\\nEnter item ");\n                scanf("%d", &item);\n                Enqueue(item);\n                break;\n            case 2:\n                Dequeue();\n                break;\n            case 3:\n                Is_Empty();\n                break;\n            case 4:\n                Display();\n                break;\n            case 5:\n                // Free All nodes ( clear heap memory)\n                \n                while(FRONT) {\n                    temp = FRONT;\n                    FRONT = FRONT->link;\n                    free(temp);\n                    printf("Memory-Cleared\\n");\n                }\n                exit(0);\n            \n        }\n    \n    } while(ch != 5);\n    \n}']))),Strings:String.raw(C||(C=Object(o.a)(['\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid swap(char *a, char *b) {\n// with out temp variable using bitwise XOR operation.\n    *a = *a^*b;\n    *b = *a^*b;\n    *a = *a^*b;\n}\n\nvoid swapUsingTemp(char *a, char *b) {\n    char t;\n    t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid strReverse( char *s) {\n    int i=0, j=strlen(s)-1;\n    \n    while(i < j) {\n        swap(&s[i], &s[j]);\n        //swapUsingTemp(&s[i], &s[j]);\n        i++;\n        j--;\n    }\n    printf("\nReverse = %s ", s);\n}\n\nvoid strReverse01( char *s) {\n    for(int i=0, j=strlen(s)-1;i < j; i++,j--) \n       swap(&s[i], &s[j]);\n    \n    printf("\nReverse01 = %s ", s);\n}\n\nvoid findlength (char *s)\n{\n  int i;\n  for (i = 0; s[i] != \'\0\'; i++);\n\n  printf ("length of %s is %d", s, i);\n}\n\nvoid strUpper (char *s)\n{\n  int i;\n  for (i = 0; s[i] != \'\0\' && (s[i] >= 97 && s[i] <= 122); i++)\n    {\n      // if( s[i] >= 97 && s[i] <=122) {\n      s[i] = s[i] - 32;\n      //  }\n    }\n  printf ("\nUpper = %s", s);\n}\n\nvoid strLower (char *s)\n{\n  int i;\n  for (i = 0; s[i] != \'\0\'; i++)\n    {\n      if (s[i] >= 65 && s[i] <= 90)\n\t{\n\t  s[i] = s[i] + 32;\n\t}\n    }\n  printf ("\nLower = %s ", s);\n}\n\nchar* substr(char *str,int pos,int n){\n    char *s = (char *)malloc(n*sizeof(char));\n    for(int i=pos;str[i]!=\'\0\';i++)\n       s[i-pos]=str[i];\n  return s;\n}\n\nvoid main ()\n{\n\n  char str1[] = "weLcome";\n\n  findlength (str1);\n  strUpper (str1);\n  strLower (str1);\n  strReverse(str1);\n\n}'],['\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid swap(char *a, char *b) {\n// with out temp variable using bitwise XOR operation.\n    *a = *a^*b;\n    *b = *a^*b;\n    *a = *a^*b;\n}\n\nvoid swapUsingTemp(char *a, char *b) {\n    char t;\n    t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid strReverse( char *s) {\n    int i=0, j=strlen(s)-1;\n    \n    while(i < j) {\n        swap(&s[i], &s[j]);\n        //swapUsingTemp(&s[i], &s[j]);\n        i++;\n        j--;\n    }\n    printf("\\nReverse = %s ", s);\n}\n\nvoid strReverse01( char *s) {\n    for(int i=0, j=strlen(s)-1;i < j; i++,j--) \n       swap(&s[i], &s[j]);\n    \n    printf("\\nReverse01 = %s ", s);\n}\n\nvoid findlength (char *s)\n{\n  int i;\n  for (i = 0; s[i] != \'\\0\'; i++);\n\n  printf ("length of %s is %d", s, i);\n}\n\nvoid strUpper (char *s)\n{\n  int i;\n  for (i = 0; s[i] != \'\\0\' && (s[i] >= 97 && s[i] <= 122); i++)\n    {\n      // if( s[i] >= 97 && s[i] <=122) {\n      s[i] = s[i] - 32;\n      //  }\n    }\n  printf ("\\nUpper = %s", s);\n}\n\nvoid strLower (char *s)\n{\n  int i;\n  for (i = 0; s[i] != \'\\0\'; i++)\n    {\n      if (s[i] >= 65 && s[i] <= 90)\n\t{\n\t  s[i] = s[i] + 32;\n\t}\n    }\n  printf ("\\nLower = %s ", s);\n}\n\nchar* substr(char *str,int pos,int n){\n    char *s = (char *)malloc(n*sizeof(char));\n    for(int i=pos;str[i]!=\'\\0\';i++)\n       s[i-pos]=str[i];\n  return s;\n}\n\nvoid main ()\n{\n\n  char str1[] = "weLcome";\n\n  findlength (str1);\n  strUpper (str1);\n  strLower (str1);\n  strReverse(str1);\n\n}']))),NQueens:String.raw(U||(U=Object(o.a)(['\n#include <stdio.h>\n#include <stdlib.h>\n#define SIZE 4\n\nvoid printSolution(int board[SIZE][SIZE]) {\n    int i,j;\n    printf("=======SOL========\n");\n    for (i = 0; i < SIZE; i++)\n    {\n        for (j = 0; j < SIZE; j++)\n           printf(" %d ", board[i][j]);\n        printf("\n");\n    }\n    printf("=================\n");\n}\n\nint isSafe(int board[SIZE][SIZE],int row, int col) {\n    /*\n               ___(i,j)\n      /\n    /\n    \n    */\n    int i,j;\n    for (j=0; j <col; j++) {\n        if(board[row][j])\n          return 0;\n    }\n    for (i=row, j=col; i>=0 && j>=0; i--,j--)\n        if(board[i][j])\n          return 0;\n    for (i=row, j=col; j>=0 && i<SIZE; i++,j--)\n        if(board[i][j])\n          return 0;\n    return 1;\n} \n\nvoid solveNQueen(int board[SIZE][SIZE], int col) {\n    \n    // BASE CASE\n    if (col >= SIZE) {\n        printSolution(board);\n        \n    } else {\n        \n        for(int row=0;row<SIZE;row++) {\n        \n            if (isSafe(board,row,col)) {\n                \n                //CHOOSE\n                board[row][col] = 1;\n                \n                //EXPLORE\n                solveNQueen(board, col+1);\n                \n                //UNCHOOSE\n                board[row][col] = 0;\n            }\n        }\n        \n    }\n    \n}\n\nvoid main ()\n{\n    int board[SIZE][SIZE] = {0};\n\n    solveNQueen(board,0);\n}'],['\n#include <stdio.h>\n#include <stdlib.h>\n#define SIZE 4\n\nvoid printSolution(int board[SIZE][SIZE]) {\n    int i,j;\n    printf("=======SOL========\\n");\n    for (i = 0; i < SIZE; i++)\n    {\n        for (j = 0; j < SIZE; j++)\n           printf(" %d ", board[i][j]);\n        printf("\\n");\n    }\n    printf("=================\\n");\n}\n\nint isSafe(int board[SIZE][SIZE],int row, int col) {\n    /*\n     \\\n      \\\n    ___\\(i,j)\n      /\n    /\n    \n    */\n    int i,j;\n    for (j=0; j <col; j++) {\n        if(board[row][j])\n          return 0;\n    }\n    for (i=row, j=col; i>=0 && j>=0; i--,j--)\n        if(board[i][j])\n          return 0;\n    for (i=row, j=col; j>=0 && i<SIZE; i++,j--)\n        if(board[i][j])\n          return 0;\n    return 1;\n} \n\nvoid solveNQueen(int board[SIZE][SIZE], int col) {\n    \n    // BASE CASE\n    if (col >= SIZE) {\n        printSolution(board);\n        \n    } else {\n        \n        for(int row=0;row<SIZE;row++) {\n        \n            if (isSafe(board,row,col)) {\n                \n                //CHOOSE\n                board[row][col] = 1;\n                \n                //EXPLORE\n                solveNQueen(board, col+1);\n                \n                //UNCHOOSE\n                board[row][col] = 0;\n            }\n        }\n        \n    }\n    \n}\n\nvoid main ()\n{\n    int board[SIZE][SIZE] = {0};\n\n    solveNQueen(board,0);\n}']))),GIT:String.raw(B||(B=Object(o.a)(["\nGIT - Directed Acylic Graph\ngit \ngit add .\ngit commit -m'modified'\ngit commit -a -m'add & commit in single step'\ngit status\ngit show\n\ngit remote -v\ngit log --pretty=oneline --graph\ngit log -p\ngit log <<commitid>> HEAD -p\ngit log <<commitid>> HEAD^^^^^..HEAD^^\ngit log <<commitid>> HEAD~5..HEAD~2\n\ngit branch branch-01 // new branch created by userA\ngit checkout branch-01\ngit checkout -b branch-02 // new branch created by userB\ngit branch // shows local branches\ngit branch -a //shows all branches includes remote branches\n** Remote branches are locally immutable\n\nuser-01:\ngit checkout -b branch-02\necho \"hello\" >> hellotest.txt\ngit commit -a -m'new filed added by user-01 for the branch created by user-02\"\n\nUser-02 is on Branch-02:\ngit branch --set-upstream <<localbranch>> <<remote refspec>> \ngit branch --set-upstream branch-02 origin/branch-02  // now tracking is done bi-directional\ngit pull // now it merges remote origin to local automatically\n\n\n\ngit branch yesterday <<commitid>>\n\ngit push command talks to the network\n\ngit push\ngit push origin <<branchName>>\ngit push remote <<branchName>>\n\ngit fetch \ngit diff branch-02 origin/branch-02\n\ngit tags are like markers\ngit tag <<TAGNAME>>  // light weight\ngit tag -a <<TAGNAME>> // Heavy Weight\n"]))),Bash:String.raw(I||(I=Object(o.a)(["\n**************************************** LINUX BOOT PROCESS ***********************************\n\n1. BIOS on the mother board checks all the input/output devices and the boot process for the computer begins.\n2. The Boot process ( GRUB / other ) looks for a section of a hard drive ( Boot sector ) that contains the data to \n   load operating system. \n3. Boot loader -> loads the linux Kernel.\n4. Linux Kernel -> load the initial RAM disk, which contains a list of device drivers and then it starts to load \n   the computer drives to eventually mount the file system from the hard disk.\n5. After the kernel is all setup and ready to to go, it then starts the initialization system\n\nVarious Initialization Systems are...\ninit --\x3e upstart --\x3e systemd \n\nSystemd is the most popular one.\n\ninit/upstart relies on bash shell scripts, but systemd replaced all the exisiting fucntionality with pre-compiled 'C' code.\nAdvandtages of systemd:\n1) Socket activation\n2) parallel execution\n\nLinux Kernel has a concept, which manages all the system resources in a hierarchial grouping & labeling called\nControl Groups (Cgroups)\nEach Cgroups - Limits the use of the system resources ( CPU, RAM ..etc )\nEach Namespace - Limits the view of the processes , creating a logical isolated boundary.\n\nSystemd took advantage of Cgroups & grouped all its processes together into their own type of Cgroups, which has its own slice \nof resource pie\n\nSystemd manages the units of services grouped together approproately names slices\n\nsystemd-cgls\nsystemd-cgtop\n\nsystemctl\nsystemctl status httpd.service\nsystemctl enable httpd.service\nsystemclt disable httpd.service\nsystemctl is-enabled httpd.servoce\nsystemctl help httpd.service\nsystemctl start httpd.service\nsystemctl stop httpd.service\nsystemctl cat httpd.service\nsystemctl mask httpd.service\nsystemctl unmask httpd.service\nsystemctl -H 198.0.0.1 status httpd.service\nsystemctl daemon-reload\nsystemctl list-unit-files\nsystemd-delta\nsystemctl edit --full <unit>\n\nsystemd journal\n\njournalctl \njournalctl -r\njournalctl -o verbose\njournalctl -o json-pretty\necho \" hello... \" | systemd-cat\njournalctl -r\njournalctl -f\njournalctl -n 20\njournalctl -k ### kernal logs\njournalctl --disk-usage\n\nhostnamectl\ntimedatectl\nlocalectl\nsystemd-analyse\n\n\nsystemd-inhibit wget http://example.com/abc.iso   ### prevents system from sleeping until it downloads huge file.\n\n/etc/fstab\ndf -Th\nlsblk\n\n\nlsmod # list kernal modules\nlscpu # displays cpu architecture\nlspci\nlsblk\nlsusb\nlsdev\n\n\n#### Special Characters\n\nsu root -  ( ### '-' at the end will make sure all the configuration settings applied to switch user root )\n/bin/false && echo 'it wont print'\n/bin/true && echo ' now it prints'\n/bin/true || echo 'it wont print'\n/bin/false || echo 'it prints'\n/bin/false; echo 'prints whatever'\n\\ $ ( ### escape characters )\n### return codes 0-true, 1 -false\necho $?\nls -al | more  ( ### '|' pipe symbol gives pagination)\nls -al > output.txt ( ### redirects output to a file )\n\n###### Environment Variables\n\nset | more\nenv | more\nshopt\nexport MYPATH = /home/user\necho $MYPATH\nhistory\n\n\n###### Processing texts\nhttps://github.com/linuxacademy1/textfiles\n\nsort numbers.txt\nsort -n numbers.txt\nsort -k2 -n numbers.txt ( ### sort second column in the text file )\ncat numbers.txt\nnl numbers.txt ( ### like cat it dispalys contents with line numbers exluding blank lines )\nnl -ba numbers.txt ( ## number blank lines)\nwc -l /etc/passwd ( ### number of lines in a file )\nwc -w /etc/passwd ( ### number of words )\nwc -c /etc/passwd ( ### number of characters )\nexpand -t 10 tabs.txt ( ### 10 spaces between each column )\ncut -c 1-5 columns.txt\ncut -d: -f 1,2,4 columns.txt\ncut -d\" \" -f 1,2 columns.txt  ( ### tab is default delimeter no need to mention )\npaste file1.txt file2.txt\njoin file1.txt file2.txt ( ### only has unique values)\nuniq lines.txt\nuniq -d lines.txt  ( ### print only duplicate unique lines )\nuniq -D lines.txt ( ### print only duplicate lines \nhead /var/log/messages ( ### displays first 10 lines )\nhead -n 15 /var/log/messages\ntail /var/log/messages\ntail -n 15 /var/log/messages\ntail -f /var/log/messages ( with updates automatically )\ncat tabs.txt\ntac tabs.txt ( ### displays content in reverse )\nsplit lines.txt\nsplit -b 512 lines.txt  ( ### 512 bytes in each file)\nsplit -k 512 lines.txt  ( ### 512 kilobytes in each file)\nsplit -l 10 lines.txt ( ### 10 lines in each file - xaa.txt)\nsplit -a 3 -l 10 lines.txt ( ### output file name xaaa.txt)\nod telnet.rpm ( ### displays binary file in octal format, other formats -b , -o, -x, -d, -f)\npr lines.txt ( ### prints the contents of the file to terminal )\npr --columns=2 lines.txt ( ### prints in 2 columns )\n\ntr 'a' 'A' < lines.txt ( ### translate command replaces a with A , but we cant use tr to replace entire word)\ntr 'a-e' 'A-E' < lines.txt \n\nTo replace entire word we use SED unility\nsed 's/the/THE/g' sedexamples.txt ( ### substitiutes the with THE globally across the file )\nsed 's/the/THE/' sedexamples.txt ( ###replaces only first instance in each line not globally )\nsed -e 's/the/NOW/g' -e 's/NOW/NEVER/g' sedexamples.txt ( ### multiple commands in a single line )\nvim sedopts.txt\ns/the/THE/g\ns/THE/NOW/g\ns/NOW/NEVER/g\n\nsed -f sedopts.txt sedexamples.txt\nmore lines.txt ( displays content page wise using tab space and it allows only forward)\nless lines.txt ( f forward b for backword)\n\n\nBasic File Management\nls -l /etc\nls -al /etc\nls -d ( lists the directories)\nmkdir -p mydir/dir1/dir2/dir3 ( creates all sub directories)\nfile /etc/* ( diplays file types information )"],["\n**************************************** LINUX BOOT PROCESS ***********************************\n\n1. BIOS on the mother board checks all the input/output devices and the boot process for the computer begins.\n2. The Boot process ( GRUB / other ) looks for a section of a hard drive ( Boot sector ) that contains the data to \n   load operating system. \n3. Boot loader -> loads the linux Kernel.\n4. Linux Kernel -> load the initial RAM disk, which contains a list of device drivers and then it starts to load \n   the computer drives to eventually mount the file system from the hard disk.\n5. After the kernel is all setup and ready to to go, it then starts the initialization system\n\nVarious Initialization Systems are...\ninit --\x3e upstart --\x3e systemd \n\nSystemd is the most popular one.\n\ninit/upstart relies on bash shell scripts, but systemd replaced all the exisiting fucntionality with pre-compiled 'C' code.\nAdvandtages of systemd:\n1) Socket activation\n2) parallel execution\n\nLinux Kernel has a concept, which manages all the system resources in a hierarchial grouping & labeling called\nControl Groups (Cgroups)\nEach Cgroups - Limits the use of the system resources ( CPU, RAM ..etc )\nEach Namespace - Limits the view of the processes , creating a logical isolated boundary.\n\nSystemd took advantage of Cgroups & grouped all its processes together into their own type of Cgroups, which has its own slice \nof resource pie\n\nSystemd manages the units of services grouped together approproately names slices\n\nsystemd-cgls\nsystemd-cgtop\n\nsystemctl\nsystemctl status httpd.service\nsystemctl enable httpd.service\nsystemclt disable httpd.service\nsystemctl is-enabled httpd.servoce\nsystemctl help httpd.service\nsystemctl start httpd.service\nsystemctl stop httpd.service\nsystemctl cat httpd.service\nsystemctl mask httpd.service\nsystemctl unmask httpd.service\nsystemctl -H 198.0.0.1 status httpd.service\nsystemctl daemon-reload\nsystemctl list-unit-files\nsystemd-delta\nsystemctl edit --full <unit>\n\nsystemd journal\n\njournalctl \njournalctl -r\njournalctl -o verbose\njournalctl -o json-pretty\necho \" hello... \" | systemd-cat\njournalctl -r\njournalctl -f\njournalctl -n 20\njournalctl -k ### kernal logs\njournalctl --disk-usage\n\nhostnamectl\ntimedatectl\nlocalectl\nsystemd-analyse\n\n\nsystemd-inhibit wget http://example.com/abc.iso   ### prevents system from sleeping until it downloads huge file.\n\n/etc/fstab\ndf -Th\nlsblk\n\n\nlsmod # list kernal modules\nlscpu # displays cpu architecture\nlspci\nlsblk\nlsusb\nlsdev\n\n\n#### Special Characters\n\nsu root -  ( ### '-' at the end will make sure all the configuration settings applied to switch user root )\n/bin/false && echo 'it wont print'\n/bin/true && echo ' now it prints'\n/bin/true || echo 'it wont print'\n/bin/false || echo 'it prints'\n/bin/false; echo 'prints whatever'\n\\\\ \\$ ( ### escape characters )\n### return codes 0-true, 1 -false\necho $?\nls -al | more  ( ### '|' pipe symbol gives pagination)\nls -al > output.txt ( ### redirects output to a file )\n\n###### Environment Variables\n\nset | more\nenv | more\nshopt\nexport MYPATH = /home/user\necho $MYPATH\nhistory\n\n\n###### Processing texts\nhttps://github.com/linuxacademy1/textfiles\n\nsort numbers.txt\nsort -n numbers.txt\nsort -k2 -n numbers.txt ( ### sort second column in the text file )\ncat numbers.txt\nnl numbers.txt ( ### like cat it dispalys contents with line numbers exluding blank lines )\nnl -ba numbers.txt ( ## number blank lines)\nwc -l /etc/passwd ( ### number of lines in a file )\nwc -w /etc/passwd ( ### number of words )\nwc -c /etc/passwd ( ### number of characters )\nexpand -t 10 tabs.txt ( ### 10 spaces between each column )\ncut -c 1-5 columns.txt\ncut -d: -f 1,2,4 columns.txt\ncut -d\" \" -f 1,2 columns.txt  ( ### tab is default delimeter no need to mention )\npaste file1.txt file2.txt\njoin file1.txt file2.txt ( ### only has unique values)\nuniq lines.txt\nuniq -d lines.txt  ( ### print only duplicate unique lines )\nuniq -D lines.txt ( ### print only duplicate lines \nhead /var/log/messages ( ### displays first 10 lines )\nhead -n 15 /var/log/messages\ntail /var/log/messages\ntail -n 15 /var/log/messages\ntail -f /var/log/messages ( with updates automatically )\ncat tabs.txt\ntac tabs.txt ( ### displays content in reverse )\nsplit lines.txt\nsplit -b 512 lines.txt  ( ### 512 bytes in each file)\nsplit -k 512 lines.txt  ( ### 512 kilobytes in each file)\nsplit -l 10 lines.txt ( ### 10 lines in each file - xaa.txt)\nsplit -a 3 -l 10 lines.txt ( ### output file name xaaa.txt)\nod telnet.rpm ( ### displays binary file in octal format, other formats -b , -o, -x, -d, -f)\npr lines.txt ( ### prints the contents of the file to terminal )\npr --columns=2 lines.txt ( ### prints in 2 columns )\n\ntr 'a' 'A' < lines.txt ( ### translate command replaces a with A , but we cant use tr to replace entire word)\ntr 'a-e' 'A-E' < lines.txt \n\nTo replace entire word we use SED unility\nsed 's/the/THE/g' sedexamples.txt ( ### substitiutes the with THE globally across the file )\nsed 's/the/THE/' sedexamples.txt ( ###replaces only first instance in each line not globally )\nsed -e 's/the/NOW/g' -e 's/NOW/NEVER/g' sedexamples.txt ( ### multiple commands in a single line )\nvim sedopts.txt\ns/the/THE/g\ns/THE/NOW/g\ns/NOW/NEVER/g\n\nsed -f sedopts.txt sedexamples.txt\nmore lines.txt ( displays content page wise using tab space and it allows only forward)\nless lines.txt ( f forward b for backword)\n\n\nBasic File Management\nls -l /etc\nls -al /etc\nls -d ( lists the directories)\nmkdir -p mydir/dir1/dir2/dir3 ( creates all sub directories)\nfile /etc/* ( diplays file types information )"])))}},n}return Object(c.a)(e,[{key:"render",value:function(){var n=this.state,t=n.programs,e=n.weblinks,i=Object.keys(t),r=Object.keys(e);return Object(h.jsx)(s.a.StrictMode,{children:Object(h.jsxs)("div",{id:"root-div",children:[Object(h.jsx)(u,{}),Object(h.jsx)("header",{className:"header",children:Object(h.jsx)("div",{class:"label-container",children:r.map((function(n){return Object(h.jsx)(f,{webLink:e[n],webLinkName:n})}))})}),Object(h.jsxs)("div",{id:"container",children:[i.map((function(n){return Object(h.jsx)(m,{programCode:t[n],programName:n})})),Object(h.jsx)(v,{}),Object(h.jsx)(D,{})]})]})})}}]),e}(s.a.Component);a.a.render(Object(h.jsx)(s.a.StrictMode,{children:Object(h.jsx)(F,{})}),document.getElementById("root"))},5:function(n,t,e){},6:function(n,t,e){},7:function(n,t,e){},8:function(n,t,e){}},[[20,1,2]]]);
//# sourceMappingURL=main.79a78d05.chunk.js.map